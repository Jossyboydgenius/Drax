


# X402 Action Provider

This directory contains the **X402ActionProvider** implementation, which provides actions to interact with **x402-protected APIs** that require payment to access.

## Directory Structure

```
x402/
├── x402ActionProvider.ts         # Main provider with x402 payment functionality
├── schemas.ts                    # x402 action schemas
├── index.ts                      # Main exports
└── README.md                     # This file
```

## Actions

- `paid_request`: Make HTTP requests to x402-protected API endpoints with automatic payment handling
- `fetch_payment_info`: Get payment information from x402-protected endpoints without making payments

## Overview

The x402 protocol enables APIs to require micropayments for access. When a client makes a request to a protected endpoint, the server responds with a `402 Payment Required` status code along with payment instructions. This action provider automatically handles the entire payment flow:

1. Makes the initial request to the protected API
2. If a 402 response is received, automatically processes the payment using the wallet
3. Retries the request with payment proof
4. Returns the API response data

## Usage

### `paid_request` Action

The `paid_request` action accepts the following parameters:

- **url**: The full URL of the x402-protected API endpoint
- **method**: HTTP method (GET, POST, PUT, DELETE, PATCH) - defaults to GET
- **headers**: Optional additional headers to include in the request  
- **body**: Optional request body for POST/PUT/PATCH requests

### `fetch_payment_info` Action

The `fetch_payment_info` action accepts the following parameters:

- **url**: The full URL of the x402-protected API endpoint
- **method**: HTTP method (GET, POST, PUT, DELETE, PATCH) - defaults to GET
- **headers**: Optional additional headers to include in the request

This action is useful for:
- Checking payment requirements before committing to a paid request
- Understanding the cost structure of an API
- Getting details about accepted payment tokens and amounts
- Debugging x402 payment configurations

## Network Support

The x402 provider currently supports the following networks:
- `base-mainnet`
- `base-sepolia`

The provider requires EVM-compatible networks where the wallet can sign payment transactions.

## Dependencies

This action provider requires:
- `axios` - For making HTTP requests
- `x402-axios` - For handling x402 payment flows

## Notes

For more information on the **x402 protocol**, visit the [x402 documentation](https://x402.gitbook.io/x402/). 



import { z } from "zod";

export const PaidRequestSchema = z
  .object({
    url: z.string().url().describe("The URL of the x402-protected API endpoint"),
    method: z
      .enum(["GET", "POST", "PUT", "DELETE", "PATCH"])
      .default("GET")
      .describe("The HTTP method to use for the request"),
    headers: z.record(z.string()).optional().describe("Optional headers to include in the request"),
    body: z.any().optional().describe("Optional request body for POST/PUT/PATCH requests"),
  })
  .strip()
  .describe("Instructions for making a paid request to an x402-protected API");

export const FetchPaymentInfoSchema = z
  .object({
    url: z.string().url().describe("The URL of the x402-protected API endpoint"),
    method: z
      .enum(["GET", "POST", "PUT", "DELETE", "PATCH"])
      .default("GET")
      .describe("The HTTP method to use for the request"),
    headers: z.record(z.string()).optional().describe("Optional headers to include in the request"),
  })
  .strip()
  .describe("Instructions for fetching payment information from an x402-protected API endpoint");


import { X402ActionProvider } from "./x402ActionProvider";
import { EvmWalletProvider } from "../../wallet-providers";
import { Network } from "../../network";
import { AxiosError, AxiosResponse, AxiosRequestConfig, AxiosInstance } from "axios";
import axios from "axios";
import * as x402axios from "x402-axios";

// Mock modules
jest.mock("axios");
jest.mock("x402-axios");

// Create mock functions
const mockRequest = jest.fn();

// Create a complete mock axios instance
const mockAxiosInstance = {
  request: mockRequest,
  get: jest.fn(),
  delete: jest.fn(),
  head: jest.fn(),
  options: jest.fn(),
  post: jest.fn(),
  put: jest.fn(),
  patch: jest.fn(),
  getUri: jest.fn(),
  defaults: {},
  interceptors: {
    request: { use: jest.fn(), eject: jest.fn(), clear: jest.fn() },
    response: { use: jest.fn(), eject: jest.fn(), clear: jest.fn() },
  },
} as unknown as AxiosInstance;

// Create a complete mock axios static
const mockAxios = {
  create: jest.fn().mockReturnValue(mockAxiosInstance),
  request: mockRequest,
  get: jest.fn(),
  delete: jest.fn(),
  head: jest.fn(),
  options: jest.fn(),
  post: jest.fn(),
  put: jest.fn(),
  patch: jest.fn(),
  all: jest.fn(),
  spread: jest.fn(),
  isAxiosError: jest.fn(),
  isCancel: jest.fn(),
  CancelToken: {
    source: jest.fn(),
  },
  VERSION: "1.x",
} as unknown as jest.Mocked<typeof axios>;

const mockWithPaymentInterceptor = jest.fn().mockReturnValue(mockAxiosInstance);
const mockDecodeXPaymentResponse = jest.fn();

// Override the mocked modules
(axios as jest.Mocked<typeof axios>).create = mockAxios.create;
(axios as jest.Mocked<typeof axios>).request = mockRequest;
(axios as jest.Mocked<typeof axios>).isAxiosError = mockAxios.isAxiosError;

// Mock x402-axios functions
jest.mocked(x402axios.withPaymentInterceptor).mockImplementation(mockWithPaymentInterceptor);
jest.mocked(x402axios.decodeXPaymentResponse).mockImplementation(mockDecodeXPaymentResponse);

// Mock wallet provider
const mockWalletProvider = {
  toSigner: jest.fn().mockReturnValue("mock-signer"),
} as unknown as EvmWalletProvider;

// Sample responses based on real examples
const MOCK_PAYMENT_INFO_RESPONSE = {
  paymentRequired: true,
  url: "https://www.x402.org/protected",
  status: 402,
  data: {
    x402Version: 1,
    error: "X-PAYMENT header is required",
    accepts: [
      {
        scheme: "exact",
        network: "base-sepolia",
        maxAmountRequired: "10000",
        resource: "https://www.x402.org/protected",
        description: "Access to protected content",
        mimeType: "application/json",
        payTo: "0x209693Bc6afc0C5328bA36FaF03C514EF312287C",
        maxTimeoutSeconds: 300,
        asset: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
        extra: {
          name: "USDC",
          version: "2",
        },
      },
    ],
  },
};

const MOCK_PAYMENT_RESPONSE = {
  success: true,
  transaction:
    "0xcbc385789d3744b52af5106c32809534f64adcbe097e050ec03d6b53fed5d305" as `0x${string}`,
  network: "base-sepolia" as const,
  payer: "0xa8c1a5D3C372C65c04f91f87a43F549619A9483f" as `0x${string}`,
};

const MOCK_PAID_REQUEST_RESPONSE = {
  success: true,
  url: "https://www.x402.org/protected",
  method: "GET",
  status: 200,
  data: "<!DOCTYPE html><html>...</html>",
  paymentResponse: MOCK_PAYMENT_RESPONSE,
};

describe("X402ActionProvider", () => {
  let provider: X402ActionProvider;

  beforeEach(() => {
    provider = new X402ActionProvider();
    jest.clearAllMocks();

    // Setup mocks
    mockAxios.create.mockReturnValue(mockAxiosInstance);
    mockWithPaymentInterceptor.mockReturnValue(mockAxiosInstance);

    // Setup axios.isAxiosError mock
    jest
      .mocked(axios.isAxiosError)
      .mockImplementation((error: unknown): boolean =>
        Boolean(
          error &&
            typeof error === "object" &&
            ("isAxiosError" in error || "response" in error || "request" in error),
        ),
      );
  });

  afterEach(() => {
    jest.clearAllMocks();
  });

  describe("supportsNetwork", () => {
    it("should support base-mainnet", () => {
      const network: Network = { protocolFamily: "evm", networkId: "base-mainnet" };
      expect(provider.supportsNetwork(network)).toBe(true);
    });

    it("should support base-sepolia", () => {
      const network: Network = { protocolFamily: "evm", networkId: "base-sepolia" };
      expect(provider.supportsNetwork(network)).toBe(true);
    });

    it("should not support unsupported EVM networks", () => {
      const network: Network = { protocolFamily: "evm", networkId: "ethereum" };
      expect(provider.supportsNetwork(network)).toBe(false);
    });

    it("should not support non-EVM networks", () => {
      const network: Network = { protocolFamily: "solana", networkId: "mainnet" };
      expect(provider.supportsNetwork(network)).toBe(false);
    });
  });

  describe("fetchPaymentInfo", () => {
    it("should successfully fetch payment info for 402 response", async () => {
      mockRequest.mockResolvedValue({
        status: 402,
        statusText: "Payment Required",
        data: MOCK_PAYMENT_INFO_RESPONSE.data,
        headers: {},
        config: {} as AxiosRequestConfig,
      } as AxiosResponse);

      const result = await provider.fetchPaymentInfo(mockWalletProvider, {
        url: "https://www.x402.org/protected",
        method: "GET",
      });

      expect(mockRequest).toHaveBeenCalledWith({
        url: "https://www.x402.org/protected",
        method: "GET",
        headers: undefined,
        validateStatus: expect.any(Function),
      });

      const parsedResult = JSON.parse(result);
      expect(parsedResult.paymentRequired).toBe(true);
      expect(parsedResult.status).toBe(402);
      expect(parsedResult.data).toEqual(MOCK_PAYMENT_INFO_RESPONSE.data);
    });

    it("should handle non-payment-protected endpoints", async () => {
      mockRequest.mockResolvedValue({
        status: 200,
        statusText: "OK",
        data: { message: "No payment required" },
        headers: {},
        config: {} as AxiosRequestConfig,
      } as AxiosResponse);

      const result = await provider.fetchPaymentInfo(mockWalletProvider, {
        url: "https://api.example.com/free",
        method: "GET",
      });

      const parsedResult = JSON.parse(result);
      expect(parsedResult.paymentRequired).toBe(false);
      expect(parsedResult.status).toBe(200);
      expect(parsedResult.data).toEqual({ message: "No payment required" });
    });

    it("should handle 402 errors with payment details in headers", async () => {
      mockDecodeXPaymentResponse.mockReturnValue(MOCK_PAYMENT_RESPONSE);

      const error = new Error("Payment required") as AxiosError;
      error.isAxiosError = true;
      error.response = {
        status: 402,
        statusText: "Payment Required",
        headers: {
          "x-payment-response": "encoded-payment-data",
        },
        data: MOCK_PAYMENT_INFO_RESPONSE.data,
        config: {} as AxiosRequestConfig,
      } as AxiosResponse;

      mockRequest.mockRejectedValue(error);

      const result = await provider.fetchPaymentInfo(mockWalletProvider, {
        url: "https://www.x402.org/protected",
        method: "GET",
      });

      expect(mockDecodeXPaymentResponse).toHaveBeenCalledWith("encoded-payment-data");

      const parsedResult = JSON.parse(result);
      expect(parsedResult.paymentRequired).toBe(true);
      expect(parsedResult.status).toBe(402);
      expect(parsedResult.paymentDetails).toEqual(MOCK_PAYMENT_RESPONSE);
    });

    it("should fallback to JSON.parse when decodeXPaymentResponse fails", async () => {
      const paymentDetailsJson = '{"amount": "10000"}';
      mockDecodeXPaymentResponse.mockImplementation(() => {
        throw new Error("Decode failed");
      });

      const error = new Error("Payment required") as AxiosError;
      error.isAxiosError = true;
      error.response = {
        status: 402,
        statusText: "Payment Required",
        headers: {
          "x-payment-response": paymentDetailsJson,
        },
        data: MOCK_PAYMENT_INFO_RESPONSE.data,
        config: {} as AxiosRequestConfig,
      } as AxiosResponse;

      mockRequest.mockRejectedValue(error);

      const result = await provider.fetchPaymentInfo(mockWalletProvider, {
        url: "https://www.x402.org/protected",
        method: "GET",
      });

      const parsedResult = JSON.parse(result);
      expect(parsedResult.paymentDetails).toEqual({ amount: "10000" });
    });

    it("should handle payment header parsing failures", async () => {
      mockDecodeXPaymentResponse.mockImplementation(() => {
        throw new Error("Decode failed");
      });

      const error = new Error("Payment required") as AxiosError;
      error.isAxiosError = true;
      error.response = {
        status: 402,
        statusText: "Payment Required",
        headers: {
          "x-payment-response": "invalid-json",
        },
        data: MOCK_PAYMENT_INFO_RESPONSE.data,
        config: {} as AxiosRequestConfig,
      } as AxiosResponse;

      mockRequest.mockRejectedValue(error);

      const result = await provider.fetchPaymentInfo(mockWalletProvider, {
        url: "https://www.x402.org/protected",
        method: "GET",
      });

      const parsedResult = JSON.parse(result);
      expect(parsedResult.paymentDetails.error).toBe("Failed to decode payment response");
      expect(parsedResult.paymentDetails.rawHeader).toBe("invalid-json");
    });

    it("should handle non-402 HTTP errors", async () => {
      const error = new Error("Server error") as AxiosError;
      error.isAxiosError = true;
      error.response = {
        status: 500,
        statusText: "Internal Server Error",
        headers: {},
        data: { error: "Internal server error" },
        config: {} as AxiosRequestConfig,
      } as AxiosResponse;

      mockRequest.mockRejectedValue(error);

      const result = await provider.fetchPaymentInfo(mockWalletProvider, {
        url: "https://api.example.com/endpoint",
        method: "GET",
      });

      expect(result).toContain("Error fetching payment info");
      expect(result).toContain("HTTP 500");
      expect(result).toContain("Internal server error");
    });

    it("should handle network errors", async () => {
      const error = new Error("Network error") as AxiosError;
      error.isAxiosError = true;
      error.request = {};

      mockRequest.mockRejectedValue(error);

      const result = await provider.fetchPaymentInfo(mockWalletProvider, {
        url: "https://api.example.com/endpoint",
        method: "GET",
      });

      expect(result).toContain("Error fetching payment info");
      expect(result).toContain("Network error");
    });
  });

  describe("paidRequest", () => {
    it("should successfully make a paid request with payment response", async () => {
      mockDecodeXPaymentResponse.mockReturnValue(MOCK_PAYMENT_RESPONSE);

      mockRequest.mockResolvedValue({
        status: 200,
        statusText: "OK",
        data: MOCK_PAID_REQUEST_RESPONSE.data,
        headers: {
          "x-payment-response": "encoded-payment-response",
        },
        config: {} as AxiosRequestConfig,
      } as AxiosResponse);

      const result = await provider.paidRequest(mockWalletProvider, {
        url: "https://www.x402.org/protected",
        method: "GET",
      });

      expect(mockWithPaymentInterceptor).toHaveBeenCalledWith(mockAxiosInstance, "mock-signer");

      expect(mockRequest).toHaveBeenCalledWith({
        url: "https://www.x402.org/protected",
        method: "GET",
        headers: undefined,
        data: undefined,
      });

      const parsedResult = JSON.parse(result);
      expect(parsedResult.success).toBe(true);
      expect(parsedResult.status).toBe(200);
      expect(parsedResult.paymentResponse).toEqual(MOCK_PAYMENT_RESPONSE);
    });

    it("should handle successful request without payment", async () => {
      mockRequest.mockResolvedValue({
        status: 200,
        statusText: "OK",
        data: { message: "Success" },
        headers: {},
        config: {} as AxiosRequestConfig,
      } as AxiosResponse);

      const result = await provider.paidRequest(mockWalletProvider, {
        url: "https://api.example.com/free",
        method: "GET",
      });

      const parsedResult = JSON.parse(result);
      expect(parsedResult.success).toBe(true);
      expect(parsedResult.status).toBe(200);
      expect(parsedResult.paymentResponse).toBe(null);
    });

    it("should fallback to JSON.parse when decodeXPaymentResponse fails", async () => {
      const paymentResponseJson = '{"transaction": "0x123"}';

      mockDecodeXPaymentResponse.mockImplementation(() => {
        throw new Error("Decode failed");
      });

      mockRequest.mockResolvedValue({
        status: 200,
        statusText: "OK",
        data: "Success",
        headers: {
          "x-payment-response": paymentResponseJson,
        },
        config: {} as AxiosRequestConfig,
      } as AxiosResponse);

      const result = await provider.paidRequest(mockWalletProvider, {
        url: "https://www.x402.org/protected",
        method: "GET",
      });

      const parsedResult = JSON.parse(result);
      expect(parsedResult.paymentResponse).toEqual({ transaction: "0x123" });
    });

    it("should handle payment response parsing failures", async () => {
      mockDecodeXPaymentResponse.mockImplementation(() => {
        throw new Error("Decode failed");
      });

      mockRequest.mockResolvedValue({
        status: 200,
        statusText: "OK",
        data: "Success",
        headers: {
          "x-payment-response": "invalid-json",
        },
        config: {} as AxiosRequestConfig,
      } as AxiosResponse);

      const result = await provider.paidRequest(mockWalletProvider, {
        url: "https://www.x402.org/protected",
        method: "GET",
      });

      const parsedResult = JSON.parse(result);
      expect(parsedResult.paymentResponse.error).toBe("Failed to decode payment response");
      expect(parsedResult.paymentResponse.rawHeader).toBe("invalid-json");
    });

    it("should handle HTTP errors", async () => {
      const error = new Error("Bad request") as AxiosError;
      error.isAxiosError = true;
      error.response = {
        status: 400,
        statusText: "Bad Request",
        headers: {},
        data: { error: "Invalid parameters" },
        config: {} as AxiosRequestConfig,
      } as AxiosResponse;

      mockRequest.mockRejectedValue(error);

      const result = await provider.paidRequest(mockWalletProvider, {
        url: "https://api.example.com/endpoint",
        method: "POST",
        body: { test: "data" },
      });

      expect(result).toContain("Error making paid request");
      expect(result).toContain("HTTP 400");
      expect(result).toContain("Invalid parameters");
    });

    it("should handle network errors", async () => {
      const error = new Error("Connection timeout") as AxiosError;
      error.isAxiosError = true;
      error.request = {};

      mockRequest.mockRejectedValue(error);

      const result = await provider.paidRequest(mockWalletProvider, {
        url: "https://api.example.com/endpoint",
        method: "GET",
      });

      expect(result).toContain("Error making paid request");
      expect(result).toContain("Network error");
      expect(result).toContain("Connection timeout");
    });

    it("should handle generic errors", async () => {
      const error = new Error("Something went wrong");

      mockRequest.mockRejectedValue(error);

      const result = await provider.paidRequest(mockWalletProvider, {
        url: "https://api.example.com/endpoint",
        method: "GET",
      });

      expect(result).toContain("Error making paid request");
      expect(result).toContain("Something went wrong");
    });

    it("should pass through all request parameters", async () => {
      mockRequest.mockResolvedValue({
        status: 200,
        data: "Success",
        headers: {},
      } as AxiosResponse);

      await provider.paidRequest(mockWalletProvider, {
        url: "https://api.example.com/endpoint",
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: { key: "value" },
      });

      expect(mockRequest).toHaveBeenCalledWith({
        url: "https://api.example.com/endpoint",
        method: "POST",
        headers: { "Content-Type": "application/json" },
        data: { key: "value" },
      });
    });
  });
});



import { z } from "zod";
import { ActionProvider } from "../actionProvider";
import { Network } from "../../network";
import { CreateAction } from "../actionDecorator";
import { PaidRequestSchema, FetchPaymentInfoSchema } from "./schemas";
import { EvmWalletProvider } from "../../wallet-providers";
import axios, { AxiosError } from "axios";
import { withPaymentInterceptor, decodeXPaymentResponse } from "x402-axios";

const SUPPORTED_NETWORKS = ["base-mainnet", "base-sepolia"];

/**
 * X402ActionProvider is an action provider for making paid requests to x402-protected APIs.
 */
export class X402ActionProvider extends ActionProvider<EvmWalletProvider> {
  /**
   * Constructor for the X402ActionProvider.
   */
  constructor() {
    super("x402", []);
  }

  /**
   * Makes a paid request to an x402-protected API endpoint.
   *
   * @param walletProvider - The wallet provider to use for payment signing.
   * @param args - The input arguments for the action.
   * @returns A message containing the API response data.
   */
  @CreateAction({
    name: "paid_request",
    description: `
This tool makes HTTP requests to APIs that are protected by x402 paywalls. It automatically handles the payment flow when a 402 Payment Required response is received.

Inputs:
- url: The full URL of the x402-protected API endpoint
- method: The HTTP method (GET, POST, PUT, DELETE, PATCH) - defaults to GET
- headers: Optional additional headers to include in the request
- body: Optional request body for POST/PUT/PATCH requests

The tool will:
1. Make the initial request to the protected endpoint
2. If a 402 Payment Required response is received, automatically handle the payment using the wallet
3. Retry the request with payment proof
4. Return the API response data

Supported on EVM networks where the wallet can sign payment transactions.
`,
    schema: PaidRequestSchema,
  })
  async paidRequest(
    walletProvider: EvmWalletProvider,
    args: z.infer<typeof PaidRequestSchema>,
  ): Promise<string> {
    try {
      // Get the viem account from the wallet provider for x402-axios
      const account = walletProvider.toSigner();

      // Create an axios instance with the payment interceptor
      const api = withPaymentInterceptor(axios.create({}), account);

      // Make the request
      const response = await api.request({
        url: args.url,
        method: args.method,
        headers: args.headers,
        data: args.body,
      });

      // Extract payment information if available
      const paymentResponseHeader = response.headers["x-payment-response"];
      let paymentResponse: Record<string, unknown> | null = null;

      if (paymentResponseHeader) {
        try {
          paymentResponse = decodeXPaymentResponse(paymentResponseHeader);
        } catch {
          // Fall back to JSON parsing if decodeXPaymentResponse fails
          try {
            paymentResponse = JSON.parse(paymentResponseHeader);
          } catch {
            paymentResponse = {
              error: "Failed to decode payment response",
              rawHeader: paymentResponseHeader,
            };
          }
        }
      }

      // Structure the response to clearly separate API response and payment details
      const result = {
        success: true,
        url: args.url,
        method: args.method,
        status: response.status,
        data: response.data,
        paymentResponse: paymentResponse,
      };

      return JSON.stringify(result, null, 2);
    } catch (error) {
      const axiosError = error as AxiosError<{ error?: string }>;
      if (axiosError.response) {
        return `Error making paid request to ${args.url}: HTTP ${axiosError.response.status} - ${axiosError.response.data?.error || axiosError.response.statusText}`;
      } else if (axiosError.request) {
        return `Error making paid request to ${args.url}: Network error - ${axiosError.message}`;
      } else {
        return `Error making paid request to ${args.url}: ${axiosError.message}`;
      }
    }
  }

  /**
   * Fetches payment information from an x402-protected API endpoint without making the payment.
   *
   * @param walletProvider - The wallet provider (not used for this action but required by interface).
   * @param args - The input arguments for the action.
   * @returns A message containing the payment requirements and endpoint information.
   */
  @CreateAction({
    name: "fetch_payment_info",
    description: `
This tool fetches payment information from x402-protected API endpoints without actually making any payments. It's useful for checking payment requirements before deciding whether to proceed with a paid request.

Inputs:
- url: The full URL of the x402-protected API endpoint
- method: The HTTP method (GET, POST, PUT, DELETE, PATCH) - defaults to GET
- headers: Optional additional headers to include in the request

The tool will:
1. Make a request to the protected endpoint
2. Receive the 402 Payment Required response with payment details
3. Return information about the payment requirements (amount, token, etc.)

Note: Payment amounts are returned in the smallest unit of the token. For example, for USDC (which has 6 decimal places) maxAmountRequired "10000" corresponds to 0.01 USDC.

This is useful for understanding what payment will be required before using the paid_request action.
`,
    schema: FetchPaymentInfoSchema,
  })
  async fetchPaymentInfo(
    walletProvider: EvmWalletProvider,
    args: z.infer<typeof FetchPaymentInfoSchema>,
  ): Promise<string> {
    try {
      // Make a simple axios request without payment interceptor to get the 402 response
      const response = await axios.request({
        url: args.url,
        method: args.method,
        headers: args.headers,
        validateStatus: status => status === 402 || (status >= 200 && status < 300), // Accept 402 responses
      });

      if (response.status === 402) {
        return JSON.stringify(
          {
            paymentRequired: true,
            url: args.url,
            status: response.status,
            data: response.data,
          },
          null,
          2,
        );
      } else {
        // Endpoint is not payment-protected or request succeeded without payment
        return JSON.stringify(
          {
            paymentRequired: false,
            url: args.url,
            status: response.status,
            data: response.data,
          },
          null,
          2,
        );
      }
    } catch (error) {
      const axiosError = error as AxiosError<{ error?: string }>;
      if (axiosError.response) {
        if (axiosError.response.status === 402) {
          // Handle 402 responses that axios might treat as errors
          const paymentResponseHeader = axiosError.response.headers["x-payment-response"];
          let paymentDetails: Record<string, unknown> | null = null;

          if (paymentResponseHeader) {
            try {
              paymentDetails = decodeXPaymentResponse(paymentResponseHeader);
            } catch {
              // Fall back to JSON parsing if decodeXPaymentResponse fails
              try {
                paymentDetails = JSON.parse(paymentResponseHeader);
              } catch {
                paymentDetails = {
                  error: "Failed to decode payment response",
                  rawHeader: paymentResponseHeader,
                };
              }
            }
          }

          return JSON.stringify(
            {
              paymentRequired: true,
              url: args.url,
              status: 402,
              paymentDetails: paymentDetails,
              data: axiosError.response.data,
            },
            null,
            2,
          );
        } else {
          return `Error fetching payment info from ${args.url}: HTTP ${axiosError.response.status} - ${axiosError.response.data?.error || axiosError.response.statusText}`;
        }
      } else if (axiosError.request) {
        return `Error fetching payment info from ${args.url}: Network error - ${axiosError.message}`;
      } else {
        return `Error fetching payment info from ${args.url}: ${axiosError.message}`;
      }
    }
  }

  /**
   * Checks if the X402 action provider supports the given network.
   *
   * @param network - The network to check.
   * @returns True if the X402 action provider supports the network, false otherwise.
   */
  supportsNetwork = (network: Network) =>
    network.protocolFamily === "evm" && SUPPORTED_NETWORKS.includes(network.networkId!);
}

export const x402ActionProvider = () => new X402ActionProvider();



Frameworks
AgentKit integrates with several popular AI frameworks, enabling you to build blockchain-capable agents using your preferred development tools.


Tip
Visit our Quickstart Guide to bootstrap your project.

The following frameworks are currently supported:

Agents SDK by OpenAI
LangChain
Eliza
Vercel AI SDK
Model Context Protocol (MCP)
Agents SDK by OpenAI
The OpenAI Agents SDK is a lightweight, Python-first framework that enables you to build production-ready AI agents with minimal abstractions. It's designed to be easy to learn while providing powerful capabilities for real-world applications.

You can find our implementation in our Replit template or the AgentKit repository.

Step 1: Clone the repository
Ensure that you have Python 3.10+ and Poetry installed:

python --version  # Should be 3.10+
poetry --version  # Make sure Poetry is installed

Clone and navigate to the example directory:

# Clone the repository
git clone https://github.com/coinbase/agentkit.git

# Navigate to the chatbot-python example
cd agentkit/python/examples/openai-agents-sdk-cdp-chatbot

Step 2: Configure Environment Variables
Copy the example environment file and configure your variables:

# Copy the example environment file
cp .env.local .env

# Edit the .env file with your credentials:
CDP_API_KEY_NAME=your_cdp_key_name # From cdp.coinbase.com
CDP_API_KEY_PRIVATE_KEY=your_cdp_private_key
OPENAI_API_KEY=your_openai_key # from platform.openai.com
NETWORK_ID="base-sepolia" # Optional, defaults to base-sepolia.

Step 3: Run the Agent
# Install dependencies
poetry install

# Run the chatbot
poetry run python chatbot.py

LangChain
LangChain is a framework for developing applications powered by language models. Our implementation is available in our Replit templates and the AgentKit repository.

Step 1: Set Up Your Development Environment
Ensure that you have Node.js 18+ installed:

node --version  # Should be 18+
npm --version   # Should be 9.7.2+

Clone and set up the repository:

# Clone the repository
git clone https://github.com/coinbase/agentkit.git

# Navigate to the root of the typescript monorepo
cd agentkit/typescript

# Install dependencies
npm install

# Build the packages locally
npm run build

# Navigate to the langchain-cdp-chatbot example or the langchain-solana-chatbot
cd examples/langchain-cdp-chatbot

Step 2: Configure Environment Variables
Copy the example environment file and configure your variables:

# Copy the example environment file
cp .env.local .env

# Edit the .env file with your credentials:
# CDP_API_KEY_NAME=your_cdp_key_name
# CDP_API_KEY_PRIVATE_KEY=your_cdp_private_key
# OPENAI_API_KEY=your_openai_key
# NETWORK_ID=base-sepolia  # Optional, defaults to base-sepolia

Step 3: Run the Agent
# Run the chatbot
npm run start

Common Issues

If you're trying to switch networks and your agent will not change, try renaming the wallet_data.txt file. Each network requires a new wallet, and if the program identifies a previously-created wallet it will not create the new one on the new network.
Adding Agent Functionality
Extend your agent with chat capabilities. To add more functionality, see the agent actions guide.

Testing Your Agent
Try these example interactions:

You: What is your wallet address?
You: transfer .001 ETH to 0x4c8bbcfc6DaE447228FcbB220C1DD4cae623EaaF
You: Register a basename for yourself that represents your identity

Eliza Framework
Eliza is a framework for building AI agents with a focus on simplicity and extensibility. For a detailed walkthrough, see our video tutorial.


Compatibility Note
When creating your CDP API key in the portal, make sure to select ECDSA as the signature algorithm. The Eliza framework integration requires CDP API keys configured with the ECDSA signature algorithm. Ed25519 signatures are not currently supported.

npx create-agentkit-app my-agent
cd my-agent
cp .env.example .env
# edit .env file with your own values
pnpm install
pnpm start

Vercel AI SDK
Vercel AI SDK is a library for building AI-powered applications with React and JavaScript/TypeScript. Our implementation demonstrates creating a terminal-style chatbot with access to CDP AgentKit actions.

Prerequisites
Checking Node Version
Before using the example, ensure that you have Node.js 18 or higher installed. You can check your Node version by running:

node --version

If you don't have the correct version, you can install it using nvm:

nvm install node

API Keys
You'll need the following API keys:

CDP API Key
OpenAI API Key
Once you have them, rename the .env-local file to .env and set the API keys to their corresponding environment variables:

CDP_API_KEY_NAME
CDP_API_KEY_PRIVATE_KEY
OPENAI_API_KEY
Setting Up the Example
Clone the repository and navigate to the example directory:

# Clone the repository
git clone https://github.com/coinbase/agentkit.git
cd agentkit

# Install dependencies and build packages
npm install
npm run build

# Navigate to the example directory
cd typescript/examples/vercel-ai-sdk-cdp-chatbot

# Start the chatbot
npm start

Testing Your Agent
Try these example interactions:

You: What is your wallet address?
You: Transfer a portion of your ETH to a random address
You: What is the price of BTC?
You: Deploy an NFT that will go super viral!
You: Deploy an ERC-20 token with total supply 1 billion

For more detailed documentation on using Vercel AI SDK with AgentKit, see the Vercel AI SDK integration guide.

Model Context Protocol (MCP)
The Anthropic Model Context Protocol (MCP) is a standardized protocol designed to facilitate structured interactions between AI models and external tools or APIs. This example demonstrates how to set up an MCP server integrated with AgentKit, allowing Claude Desktop to access the full set of CDP AgentKit actions.

Prerequisites
Checking Node Version
Before using the example, ensure that you have Node.js 18 or higher installed. You can check your Node version by running:

node --version

If you don't have the correct version, you can install it using nvm:

nvm install node

API Keys
You'll need the following API key:

CDP API Key
You'll need to configure the Claude Desktop config file with your CDP API keys. Copy the contents from claude_desktop_config.json to your Claude Desktop config file and update the following:

Update the args path to match the location of your built index.js file.
Set your CDP API keys in the env section:
CDP_API_KEY_NAME
CDP_API_KEY_PRIVATE_KEY
Then, navigate to the claude_desktop_config.json file found in your Claude Desktop app's settings and update its contents to match the contents of our provided claude_desktop_config.json file.

Setting Up the Example
Clone the repository and navigate to the example directory:

# Clone the repository
git clone https://github.com/coinbase/agentkit.git
cd agentkit

# Install dependencies and build packages
npm install
npm run build

# Navigate to the MCP example directory
cd typescript/examples/model-context-protocol-cdp-server

Configure your Claude Desktop by updating the claude_desktop_config.json file with your CDP API keys and the correct path to your built index.js file.

To use the chatbot, simply open Claude Desktop after configuring your API keys. The MCP server will run automatically when you interact with Claude.

Testing Your Agent
Try these example interactions in Claude Desktop:

Transfer a portion of your ETH to a random address
What is the price of BTC?
Deploy an NFT that will go super viral!
Deploy an ERC-20 token with total supply 1 billion


Integrate LangChain Tools
LangChain has revolutionized the way developers interact with language models and build powerful AI applications. One of its most compelling features is the extensive ecosystem of tools and integrations that allow developers to quickly and easily extend their agents' capabilities.

The Power of LangChain Tools
LangChain's true strength lies in its vast array of community-supported tools and integrations. These tools enable developers to:

Rapidly expand agent capabilities: Integrate with various APIs, databases, and services without writing extensive custom code
Leverage specialized functionalities: Access domain-specific tools for tasks like image generation, social media posting and consumption, internet search, data analysis, or blockchain interactions
Create multi-modal agents: Combine different types of interactions (text, image, code) within a single agent
Stay up-to-date: Benefit from a constantly growing ecosystem of tools maintained by the community
By utilizing these tools, developers can create sophisticated AI agents that can perform a wide range of tasks, from generating images to sending emails, all through natural language interfaces.

Adding the Dall-E Image Generator to Your Agent
In this guide, we'll walk through the process of adding the Dall-E Image Generator tool to an existing LangChain agent. This will demonstrate how easily you can enhance your agent's capabilities using community toolkits.

Prerequisites
An existing AgentKit setup, like the one in our Replit template
Python 3.10+ or NodeJS 18+
OpenAI API key
Step 1: Install Required Packages
First, ensure you have the necessary packages installed:

npm install @langchain/openai

Step 2: Import Required Modules
Add the following imports to your existing imports:

import { DallEAPIWrapper } from "@langchain/openai";

Step 3: Set Up OpenAI API Key
If you haven't already, set up your OpenAI API key as an environment variable and ensure the account is funded:

export OPENAI_API_KEY="your_api_key"

Step 4: Load the Dall-E Tool
Before initializing your agent, load the Dall-E tool:

const dallETool = new DallEAPIWrapper({
  n: 1,
  model: "dall-e-3",
  apiKey: process.env.OPENAI_API_KEY,
});

Step 5: Combine Tools
Add the Dall-E tool to your existing tools:

const allTools = [...getLangChainTools(agentkit), dallETool];

Step 6: Update Agent Initialization
Modify your create_react_agent call to include the new tools:

async function initializeAgent() {
  // Initialize LLM
  const llm = new ChatOpenAI({
    model: "gpt-4o-mini",
  });

  // ... (previously mentioned code for creating and instantiating tools) ...

  // Create React Agent using the LLM and CDP AgentKit tools
  const agent = createReactAgent({
    llm,
    tools: allTools,
    checkpointSaver: memory,
    messageModifier:
    "You are a helpful agent that can interact onchain using the Coinbase Developer Platform AgentKit...",
  });

  return { agent, config: agentConfig };
}

Now your agent is equipped with the ability to generate images using Dall-E alongside its existing CDP capabilities. You can test it by asking the agent to generate images through natural language requests.


Wallet Management
AgentKit supports multiple wallet providers, with the CDP Wallet API being the default implementation. It supports the following operations, alongside compatibility with the full suite of CDP products including Onramp, onchain reputation score, and Commerce:

Creating API Wallets
Signing transactions
Deploying and interacting with tokens
Invoking smart contracts and querying chain state
Wallet Configuration
You can configure AgentKit to use a CDP wallet or a custom wallet provider.

The CDP Wallet v2 API is the recommended wallet provider for AgentKit. It supports both EVM and Solana chains, seamlessly and securely handles private keys, and is compatible with viem.

import {
  AgentKit,
  CdpV2WalletProvider,
  CdpV2EvmWalletProvider, // for evm
  CdpV2SolanaWalletProvider, // for solana
} from "@coinbase/agentkit";

// Configure CDP Wallet Provider
const cdpWalletConfig = {
  apiKeyId: process.env.CDP_API_KEY_ID, // from https://portal.cdp.coinbase.com , see v2 wallet quickstart for more details
  apiKeySecret: process.env.CDP_API_KEY_SECRET,
  walletSecret: process.env.CDP_WALLET_SECRET,
  idempotencyKey: process.env.IDEMPOTENCY_KEY, // optional, used for account creation
  address: process.env.ADDRESS as `0x${string}` | undefined, // optional, used for existing account
  networkId: process.env.NETWORK_ID, // e.g. "base", "base-sepolia", "solana"
};

const walletProvider = await CdpV2WalletProvider.configureWithWallet(cdpWalletConfig);

// ...
// Initialize AgentKit
const agentkit = await AgentKit.from({
  walletProvider,
  actionProviders: [],
});

Default Operations
By default, AgentKit supports the following basic wallet operations:

get_wallet_details - Get details about the Wallet, like the address
transfer - Transfer assets between addresses
get_balance - Get the balance of an asset
You can add additional actions or action providers upon agent instantiation.


Prompts and Models
Changing Models
AgentKit is model-agnostic, and changing which model depends on which framework you are using.

These LangChain guides in Python and Node.js will help you change the model for your LangChain agent.

For the Node.js version, you can change the model similarly.

For any model that can be accessed through the OpenAI standard, you can change the BaseURL as specified by your model provider's documentation. You can also specify additional configuration options such as maxTokens, temperature, and topP. Here are some examples:

# requires AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY as env variables
from langchain_aws import ChatBedrockConverse

llm = ChatBedrockConverse(
    model_id="us.amazon.nova-pro-v1:0", # Change to any Bedrock Model ID 
    max_tokens=1024,
    # other params...
    )

Prompting Guide
The prompts you use for your agent can significantly impact its personality and performance. Here are some tips to help you get started:

Agent State Modifier: The agent state modifier is the first thing the agent sees. It is used to set the agent's initial state and can be used to set the agent's personality. If there are specific instructions for the agent, they should be included here. However, do not treat it as as a place for guardrails, as a well-written prompt can get around text-based instructions.
Action Prompt: Every action has an associated prompt that gives the agent context on how to use the action. If there are specific things an agent should know about the parameters, how to ask the user for clarification, or assumptions to make in default cases when the user does not mention a specific parameter, this prompt is a great place to include them.


Architecture Explained
AgentKit is a modular toolkit that allows you to build AI agents that can take actions onchain. It is designed to be:

Wallet provider agnostic
Framework agnostic
Model agnostic
Core Components
The major components of AgentKit are:

1. AgentKit Core (@coinbase/agentkit/ coinbase-agentkit)
The heart of AgentKit is the @coinbase/agentkit (or coinbase-agentkit in Python) package, which provides:

Common interfaces and classes for "Action Providers" (small units of functionality) and "Wallet Providers" (providers of wallets)
Simple configuration layer for API keys and environment variables
Shared logic for interacting with the CDP Wallet API or any wallet provider
Exposed interfaces/abstract classes for "Actions" that define:
Method signatures
Input schemas
Operation logic
To create an agent, you will need to configure AgentKit with API keys and environment variables, and create the AgentKit instance that associates a wallet provider and action providers.
const agentKit = await AgentKit.from({
  walletProvider,
  actionProviders: [cdp, erc721, pyth, wallet],
});

2. Framework Extensions
Built on top of AgentKit Core, these optional packages adapt core actions to specific agent frameworks or workflows. These are primarily what developers will use to build their agents.

These frameworks typically wrap core actions with framework-specific tools, adapt to AI framework plugin interfaces, add "agentic" behaviors for AI model interaction, and handle action discovery and execution.

Available Extensions
agentkit-langchain: Deep integration with LangChain Tools (Python and TypeScript)
farcaster-langchain: Farcaster interaction capabilities
twitter-langchain: Twitter (X) interaction capabilities
// Integrate with AI framework (e.g., LangChain)
const tools = await getLangChainTools(agentKit);

3. Wallet Providers
Default Implementation
Uses Wallet API from Coinbase Developer Platform
Handles address management, transaction signing, and onchain interactions
Configuration Examples
TypeScript:

const agentKit = await AgentKit.from({
  walletProvider,
  actionProviders: [cdp, erc721, pyth, wallet],
});

Extensibility
Support for alternative wallet providers:
Hardware wallets
Browser extension wallets
Hybrid approaches
Flexible wallet data import/export for state persistence
4. Action Providers
Actions are the core unit of functionality in AgentKit.

Action Components
Each action includes:

Name: e.g., "transfer", "deploy_token", "farcaster_post_cast"
Input Schema: Required arguments for the action
Method: Execution logic, typically interfacing with CDP SDK
Organization
Actions are grouped into logical namespaces:
actions/cdp/defi: DeFi operations
actions/cdp/social: Social platform interactions


Hosting Agents
There are several options for hosting your AgentKit agents, from managed AI agent platforms to traditional cloud hosting. This guide covers the main approaches and helps you choose the right one for your needs.

NEAR AI provides a platform for building and hosting AI agents with built-in support for various frameworks including AgentKit.

Requirements
Python 3.9 - 3.11 (3.12 - 3.13 is not supported)
NEAR Account (can be created at wallet.near.org)
Virtual environment (recommended)
Quick Setup
Create and activate a Python virtual environment:
# Using venv
python -m venv .venv
source .venv/activate

# Or using conda
conda create -n nearai python=3.11
conda activate nearai

Install the NEAR AI CLI:
pip install nearai

Login to NEAR AI:
nearai login

Create a new agent:
nearai agent create

Configure your agent's framework in metadata.json:
{
  "details": {
    "agent": {
      "framework": "agentkit"
    }
  }
}

For detailed setup instructions, see:

NEAR AI CLI Guide
NEAR AI Quickstart Guide
Framework Support Documentation
Choosing a Hosting Solution
Consider these factors when selecting a hosting solution:

Managed Platforms (Autonome, NEAR AI): Best for quick deployment and managed infrastructure
Cloud Hosting: Ideal for custom requirements and full control over infrastructure
Local Hosting: Perfect for development and testing
For most users, managed platforms like Autonome or NEAR AI provide the easiest path to production. For enterprise needs or specific requirements, traditional cloud hosting offers more control and customization options.


Welcome to Wallet API
Wallet API enables developers to create secure wallets and automate onchain actions with minimal code, focusing on product innovation rather than complex wallet infrastructure management.


Note
Wallet API now supports Smart Wallets! See Smart Wallets for details.

Designed for Developers
Unlike most wallets designed for end-users, Wallet API is built specifically for developer needs:

Simplicity: Automate common blockchain interactions with powerful, scalable, and straightforward API calls including Trades, Transfers, Staking, and Onchain Interactions. Our SDKs support NodeJS and Python.
Enhanced Security: Utilize Coinbase's best-in-class security and advanced Multi-Party Computation (MPC) for robust private key protection on 2-of-2 Coinbase-Managed Wallets. See Securing a Wallet to learn more.
Multi-Network Support:
Primary support for Base, where developers benefit from a rich suite of Coinbase developer tools.
Additional support for Ethereum, Arbitrum, and Polygon.
Gasless sends for USDC, EURC & cbBTC: Send USDC, EURC and cbBTC without paying gas fees on Base Mainnet.
Custom Security Options
Multi-Party Computation (MPC) is a cryptographic technique that splits a private key into multiple shards, eliminating single points of failure.

Wallet API supports different levels of security that meet your needs:

Developer-Managed (1-of-1)

Quick wallet creation with self-managed keys
Ideal for rapid development and testing
Lighter security using traditional full private keys
Coinbase-Managed (2-of-2)

Shared key management with Coinbase
Splits private key into multiple shards, eliminating single points of failure
Recommended for production environments where funds are at risk

Note
Additional custody and key management models are planned for future releases, along with key backup and recovery.

Solutions You Can Build
Automated One-to-Many Payments: Send to millions of recipients with a few lines of code.
AgentKit: Create autonomous AI agents with access to onchain functionality.
Global Payment Solutions: Implement fast, free USDC transfers in existing applications.
In-Game Economies: Streamline in-game asset and transaction handling.
Fintech Innovation: Incorporate crypto functionalities to traditional financial products.

Tip
Wallet API pairs perfectly with our self-custodial, user-facing Smart Wallet. Together, you get the benefit of programmatic developer actions and a seamless user onboarding experience. To see the differences between the two solutions, see our Wallet Comparison.

Start Building Today
Join the #wallet-api channel of the CDP Discord to:

Access FAQs
Schedule project discussions
Connect with other developers
We welcome your feedback and suggestions for improvement.


Quickstart
The CDP SDK allows you to create wallets and send funds onchain within minutes. In this quickstart, you will learn how to create a wallet, fund it with testnet ETH, transfer funds between wallets, and trade assets.


Tip
See Securing a Wallet to learn how to protect your wallets.

What You'll Learn
How to install the CDP SDK
How to create a Developer-Managed Wallet and view its default address
How to fund your wallet with testnet ETH
How to transfer funds between wallets
How to trade assets in a wallet
Requirements

Info
Make sure that your developer environment satisfies all of the requirements before proceeding through the quickstart.

Node.js 18+

The Coinbase server-side SDK requires Node.js version 18 or higher and npm version 9.7.2 or higher. To view your currently installed versions of Node.js, run the following from the command-line:

node -v
npm -v

We recommend installing and managing Node.js and npm versions with nvm. See Installing and Updating in the nvm README for instructions on how to install nvm.

Once nvm has been installed, you can install and use the latest versions of Node.js and npm by running the following commands:

nvm install node # "node" is an alias for the latest version
nvm use node

Installation
Clone CDP SDK quickstart template
The CDP SDK provides a quickstart template to get started with the SDK. Clone the repository and navigate to the quickstart template directory:

git clone git@github.com:coinbase/coinbase-sdk-nodejs.git; cd coinbase-sdk-nodejs/quickstart-template

Install the dependencies:

npm install

The file index.js contains the code to perform your first transfer with the CDP SDK. Let's break down the content of this file.

Creating a Wallet
The following instructions illustrate how to create a Developer-Managed (1-of-1) Wallet from scratch, using the CDP SDK.

Create a CDP Secret API key
Initialize the CDP SDK by passing your downloaded API key file
Create a new Developer-Managed (1-of-1) wallet

Tip
This quickstart creates wallets on Base Sepolia testnet. You can create wallets across various EVM networks, including Base, Ethereum L1, and Polygon.

Initialize the SDK by passing your API key information:

index.js
import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";

const apiKeyName = "Copy your secret API key name here."
const apiKeyPrivateKey = "Copy your secret API key's private key here."

Coinbase.configure(apiKeyName, apiKeyPrivateKey)

Another way to initialize the SDK is by sourcing the API key from the JSON file that contains your secret API key, downloaded from the CDP portal:

index.js
let coinbase = Coinbase.configureFromJson({ filePath: '~/Downloads/cdp_api_key.json' });

Now create a wallet:

index.js
// Create a new Wallet
let wallet = await Wallet.create();
console.log(`Wallet successfully created: `, wallet.toString());

// Wallets are not saved locally by default. Refer to the Wallets concept for more information.

Wallets are initialized with a single default Address, accessible via getDefaultAddress:

index.js
let address = await wallet.getDefaultAddress();
console.log(`Default address for the wallet: `, address.toString());


Caution
In a production environment, we recommend turning on IP Whitelisting and using the 2-of-2 Coinbase-Managed Wallet for additional security.

The wallet created should be persisted to avoid losing access to it. Refer to Persisting a wallet section for more information.

Importing a Wallet
The following instructions illustrate how to bring your own wallet into the CDP ecosystem, as a Developer-Managed (1-of-1) Wallet, using the CDP SDK.

Create a CDP Secret API key
Initialize the CDP SDK by passing your downloaded API key file
Create a new Developer-Managed (1-of-1) wallet using your BIP-39 mnemonic seed phrase

Tip
This quickstart creates wallets on Base Sepolia testnet. You can create wallets across various EVM networks, including Base, Ethereum L1, and Polygon.

Initialize the SDK by passing your API key information:

index.js
import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";

const apiKeyName = "Copy your secret API key name here."
const apiKeyPrivateKey = "Copy your secret API key's private key here."

Coinbase.configure(apiKeyName, apiKeyPrivateKey)

Another way to initialize the SDK is by sourcing the API key from the JSON file that contains your secret API key, downloaded from the CDP portal:

index.js
let coinbase = Coinbase.configureFromJson({ filePath: '~/Downloads/cdp_api_key.json' });

Now import your wallet:

index.js
// Import your Wallet into CDP using your BIP-39 mnemonic seed phrase.
// NOTE 1: For security reasons, we recommend storing your seed phrase in an environment variable.
// NOTE 2: Your wallet's seed and seed phrase will not leave your device.
let wallet = await Wallet.import({ mnemonicPhrase: process.env.MNEMONIC_PHRASE });
console.log(`Wallet successfully created: `, wallet.toString());

// Wallets are not saved locally by default. Refer to the Wallets concept for more information.

Wallets are initialized with a single default Address, accessible via getDefaultAddress:

index.js
let address = await wallet.getDefaultAddress();
console.log(`Default address for the wallet: `, address.toString());


Caution
In a production environment, we recommend turning on IP Whitelisting and using the 2-of-2 Coinbase-Managed Wallet for additional security.

Once initialized, your imported wallet should be stored as a Wallet data object, for easy re-instantiation. Refer to Persisting a wallet section for more information.

Funding a Wallet
Wallets do not have funds on them to start. For Base Sepolia and Ethereum Sepolia testnets, we provide a faucet method to fund your wallet with testnet ETH.

index.js
const faucetTransaction = await wallet.faucet();

// Wait for transaction to land on-chain.
await faucetTransaction.wait();

console.log(`Faucet transaction completed successfully: `, faucetTransaction.toString());

Transferring Funds
Now that your faucet transaction has successfully completed, you can send the funds in your wallet to another wallet. The code below creates another wallet, and sends testnet ETH from the first wallet to the second:


Warning
Creating multiple transactions simultaneously can lead to failures.

All transfers, excluding gasless transfers, do not support concurrent transactions. We recommend running sequential calls and waiting for the previous transaction to confirm before continuing.

See Processing multiple transfers for same address as an example. If you need more assistance, reach out to us on Discord in #wallet-api.

index.js
let anotherWallet = await Wallet.create();
console.log(`Second Wallet successfully created: `, anotherWallet.toString());

const transfer = await wallet.createTransfer({
  amount: 0.00001,
  assetId: Coinbase.assets.Eth,
  destination: anotherWallet,
});

// Wait for the transfer to settle.
await transfer.wait()

// Check if the transfer successfully completed on-chain.
if (transfer.getStatus() === 'complete') {
  console.log(`Transfer successfully completed: `, transfer.toString());
} else {
  console.error('Transfer failed on-chain: ', transfer.toString());
}

See Transfers for more information.

You can create your wallet, fund it with testnet tokens and perform your first transfer by running the following command:

npm start

Trading Assets
On base-mainnet you can trade between different assets from your wallet. Since trading is only supported on mainnet wallets, wallet should be funded with real assets before trading. The code below creates a wallet and trades some ETH to USDC and then all of the USDC to WETH:

Refer to trade.js for a complete example of trading assets.

trade_assets.js
import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";

let coinbase = Coinbase.configureFromJson({ filePath: '~/Downloads/cdp_api_key.json' });

// Create a Wallet on base-mainnet to trade assets with.
let wallet = await Wallet.create({ networkId: Coinbase.networks.BaseMainnet });

// Fund the Wallet's default Address with ETH from an external source.
// Trade 0.00001 ETH to USDC.
let trade = await wallet.createTrade({
  amount: 0.00001,
  fromAssetId: Coinbase.assets.Eth,
  toAssetId: Coinbase.assets.Usdc
});

await trade.wait();

if (trade.getStatus() === 'complete') {
  console.log(`Trade successfully completed: `, trade.toString());
} else {
  console.log(`Trade failed on-chain: `, trade.toString());
}

// Trade the wallet's full balance of USDC to WETH.
let trade2 = await wallet.createTrade({
  amount: wallet.getBalance(Coinbase.assets.Usdc),
  fromAssetId: Coinbase.assets.Usdc,
  toAssetId: Coinbase.assets.Weth,
});

await trade2.wait();

if (trade2.getStatus() === "complete") {
  console.log(`Trade successfully completed: `, trade2.toString());
} else {
  console.log(`Trade failed on-chain: `, trade2.toString());
}

See Trades for more information.


Warning
The Developer-Managed Wallets created in the above quickstart are not persisted. We recommend Coinbase-Managed Wallets in production environments.



Fund Wallets
Funding a wallet means transferring crypto to a wallet address. Having crypto in your wallet is key to many use cases such as using the wallet to make payments, transact onchain, or deploy smart contracts. There are several ways to fund an API Wallet:

Wallet Funding API (Alpha): With CDP SDK, you can fund your wallet from fiat currency in a bank account with a single API call. This method is currently limited to US-based individuals using US debit card (without 3DS verification) payment methods configured in a Coinbase account. We will add support for businesses, and for additional payment methods soon. This method currently supports funding wallets with USDC and ETH, with additional assets coming soon.
Send crypto from an external wallet: If you already have crypto in another wallet, you can fund your API Wallet by transferring crypto from the other wallet to your API Wallet.
Use Coinbase Product APIs: You can use Coinbase Product APIs (Retail / Exchange) to buy and transfer crypto to your API Wallet address.

Tip
Start by creating a Coinbase account if you don’t already have one, and add payment method(s).

Wallet Funding API (Alpha)
For this method, you need a Coinbase account with a US debit card (non-3DS) payment method configured. CDP SDK provides methods to get a quote if desired, and call the Wallet Funding API to buy crypto and transfer it to the indicated API Wallet. If you have multiple debit cards set up, this method will use the first non-3DS, active, verified card you added. The sections below walk through how to use these SDK methods.

Supported Assets
You can fund your wallet with assets that are supported in the Coinbase App for the applicable network. Not all assets are available to fund on every network; availability in the Wallet Funding API will mirror an asset's availability in the Coinbase App.

For all of our supported EVM networks eth and usdc will be supported, and you can Trade those assets for your desired asset.

Limits
Wallet funding limits are the same as your Coinbase account limits.

Get a quote
You may want to obtain estimates for the network fee and Coinbase fee (if applicable - save on fees with Coinbase One) associated with your wallet funding operation, before executing it. You can do this by calling the quoteFund method, as shown below. The quoteFund method returns a QuoteID and estimated network and Coinbase fees, as applicable.

// Obtain a quote for funding a wallet with 100 USDC
const myQuote = await wallet.quoteFund({ amount: 100, assetId: 'usdc' });

// Parameters of the quote you can inspect to see if you want to execute it.
// Crypto Amount requested
console.log(myQuote.getAmount().getAmount());
// Crypto Amount converted to Fiat + Buy Fee
console.log(myQuote.getFiatAmount());
// Buy fee
console.log(myQuote.getBuyFee().amount);
// Transfer fee
console.log(myQuote.getTransferFee().getAmount());

Fund your API Wallet
The wallet.fund() method will buy a specified amount of a given crypto asset using your Coinbase account, and transfer it to your API Wallet using the network you configured when creating your wallet. Fees, if applicable, will be charged in addition to the target amount.

If you have already generated a quote, you can simply execute it to initiate wallet funding:

// Execute the previously quoted wallet funding operation
let fundOperation = await myQuote.execute();

// Wait for the funding operation to settle
await fundOperation.wait();

The operation shown above will execute the previously-quoted funding operation - in this example, buying 100 USDC, then transferring the 100 USDC to your API Wallet using the network associated with your API Wallet.

If you want to directly execute a wallet funding operation without first getting a quote, you may directly call the wallet.fund method specifying the amount and crypto asset.

// Initiate the funding operation
const fundOperation = await wallet.fund(100, 'usdc');

// Wait for the funding operation to settle
await fundOperation.wait();

Receive crypto from an external wallet
You can fund your API Wallet by receiving crypto from an external wallet. To do this, get the deposit address of the API Wallet by calling the getDefaultAddress API.

// Get the default_address in the wallet, which will be the deposit address.
let address = await wallet.getDefaultAddress();
console.log(`Deposit Address: ${address}`);

Once you have the deposit address, you can send crypto to the deposit address from an external wallet.

Use Coinbase products to move funds to your API Wallets
Another way to move funds to your API Wallet is to use Coinbase products.

Sign up on Coinbase
The first step in using Coinbase products to move funds to your API Wallet is to create a Coinbase account.

If you are an individual, you can use a personal Coinbase App account.

If you are a business, you can use Coinbase Exchange. The onboarding process will involve answering questions about yourself and your business. If you need assistance in business onboarding, reach out to us in the #wallet-api channel of the CDP Discord.

Send funds from Coinbase Retail / Exchange
Once you have onboarded to Retail / Exchange, you can buy crypto with payment methods of your choice on these platforms.

Supported payment methods on Coinbase Exchange can be found here.
Supported payment methods on Coinbase Retail can be found here.
You can then move the funds to your wallet with the code snippets below.

Move funds from Retail via Coinbase App APIs
Expand to see code snippet to move funds from retail to an API Wallet
Move funds from Exchange via Exchange API
Expand to see code snippet to move funds from exchange to an API Wallet
Withdrawing crypto to fiat
You may wish to convert crypto in your API Wallet to fiat in a bank account. You can do this using the following steps:

Get your Coinbase App deposit address for the same network as the API Wallet from which you want to withdraw
Use the Transfer API to move funds from your API Wallet to your Coinbase account
Once the crypto is in your Coinbase account, you can sell crypto for cash
Lastly, follow the steps in cash out your funds for fiat in your selected payment method
If you are interested in an API-based crypto-to-fiat withdrawal feature, please reach out to us in the #wallet-api channel of the CDP Discord.



Smart Contract Interactions
Wallet API supports smart contract writes, reads, smart contract token deployments, and message signing. This allows developers to unlock a wide range of onchain activities while abstracting complexity from end-users.

Example Use Cases
Telegram bots for anything: Beyond swapping and sending, developers can create Telegram bots for any smart contract functionality.
Multi-step smart contract interactions: Create complex, programmatic DeFi applications that abstract difficult steps from your user. Truly programmatic money legos.
Smart Contract Writes
Smart contracts live on a blockchain and programmatically enforce and execute the terms of an agreement. Integrating smart contracts with API Wallets enables:

Complex, multi-step operations triggered by a single user action.
Offchain actions with onchain verification and execution.
Limitless interactions with any onchain app or protocol.
Examples
Invoking (Calling) a Contract
We natively support the following standard contract interfaces, without you providing an ABI:

ERC-20 (fungible tokens)
ERC-721 (NFTs)
ERC-1155 (Multi token standard)
However, any other contracts require providing the ABI. If you are interested in cached ABIs for more common smart contracts, reach out to us in the #wallet-api channel of the CDP Discord.

A contract ABI (Application Binary Interface) is the way to interact with a smart contract, both externally and contract-to-contract. It is a file defining the various methods and parameters of the contract.

The SDK also supports payable transactions, which are transactions that send ETH to the contract. See the Basename Registration guide for an example of a payable transaction.

Transfer an ERC-721 NFT
Here's an example of using invokeContract to transfer an ERC-721 NFT:

import { Coinbase, Wallet } from "@coinbase/coinbase-sdk";
import os from "os";

const coinbase = Coinbase.configureFromJson({ filePath: `${os.homedir()}/Downloads/cdp_api_key.json`, useServerSigner: true });

const wallet = await Wallet.create({ networkId: Coinbase.networks.EthereumMainnet });

// Since this is an ERC-721 NFT, there's no need to define the ABI
const transferFromArgs = {
  from: "0xFrom",
  to: "0xmyEthereumAddress",
  tokenId: "1000",
};

const contractInvocation = await wallet.invokeContract({
  contractAddress: "0xYourNFTContractAddress",
  method: "transferFrom",
  args: transferFromArgs,
});

// Wait for the contract invocation transaction to land on-chain.
await contractInvocation.wait();

Invoking an arbitrary smart contract
This is an example of using invokeContract on an arbitrary contract, where the ABI must be explicitly provided.

// Define the ABI of the contract function you want to interact with
const abi = [
  {
    name: "transfer",
    type: "function",
    inputs: [
      { name: "to", type: "address" },
      { name: "value", type: "uint256" },
    ],
    outputs: [{ name: "", type: "uint256" }],
    stateMutability: "nonpayable",
  },
];

const transferArgs = {
  to: "0xmyEthereumAddress",
  value: "100",
};

const contractInvocation = await wallet.invokeContract({
  contractAddress: "0xYourContractAddress",
  method: "transfer",
  args: transferArgs,
  abi,
});

// Wait for the contract invocation transaction to land on-chain.
await contractInvocation.wait();

Viewing transaction receipts and logs
The CDP SDK supports parsing transaction receipts and logs from contract invocations. Here's an example.

const transferArgs = {
  to: "0xmyEthereumAddress",
  value: "1",
};

const contractInvocation = await wallet.invokeContract({
  contractAddress: "0x036CbD53842c5426634e7929541eC2318f3dCF7e", // USDC contract on Base Sepolia
  method: "transfer",
  args: transferArgs,
});

await contractInvocation.wait();

// Get the transaction content and receipt.
const transactionContent = contractInvocation.getTransaction().content();
const receipt = transactionContent.receipt;

const logs = receipt.logs;

for (const log of logs) {
    console.log(log.address); // Contract address that emitted the log event
    console.log(log.topics); // Array of decoded topics for the log event
    console.log(log.data); // Data for the log event
}

Smart Contract Reads
Smart contract support being queried and returning state data without explicitly modifying their state. Readable functions are useful for retrieving current contract state, calculating values, or checking conditions before performing transactions.

Including an ABI is optional, but without it, the CDP SDK will not be able to determine the return type of the function, and the return value will not be parsed. With an ABI, Node.js types are inferred and can be used directly. In Python, the SDK will automatically convert to the expected type at runtime.

Examples
Here's an example of reading from a smart contract using the CDP SDK:

import { Coinbase, readContract } from "@coinbase/coinbase-sdk";

// balance is automatically of type bigint
const balance = await readContract({
networkId: "base-mainnet",
abi: erc20Abi,
contractAddress: USDC_BASE_MAINNET_ADDRESS as 0x${string},
method: "balanceOf",
args: { account: "0xF977814e90dA44bFA03b6295A0616a897441aceC" },
});

console.log(balance);

// balance is of type unknown, so as bigint is needed
const balance = await readContract({
networkId: "base-mainnet",
contractAddress: USDC_BASE_MAINNET_ADDRESS as 0x${string},
method: "balanceOf",
args: { account: "0xF977814e90dA44bFA03b6295A0616a897441aceC" },
}) as bigint;


Message Signing
Signing is a cryptographic action that lets a user prove ownership of an address without exposing their private key or initiating an onchain transaction. When a user signs a message, the signed message:

Demonstrates control of the address.
Can be used to approve a particular action or set of actions.
Is a verifiable piece of cryptographic data that can be used onchain or offchain.
In existing apps, signatures are used to authorize transfers of particular assets, prove ownership of an address to sign into an app, and vote in Decentralized Autonomous Organizations (DAOs).

Example Use Cases
Identity/Sign-on: Use API Wallets to sign into applications or prove ownership of a wallet.
Multi-signature API Wallets: Have multiple parties sign partial messages, which are then combined to create a valid transaction or decrypt information.
Scalable, high-frequency interactions: Have games or trading apps use signatures to verify actions and submit batch updates to the blockchain.
Examples
Signing a Payload
You can sign an arbitrary string using the EIP-191 standard.

SDK Documentation

// EIP-191 Message signing of hashed payload.
const message: string = hashMessage("hello world")

let payloadSignature: PayloadSignature = await wallet.createPayloadSignature(message);
payloadSignature = await payloadSignature.wait();

Signing Typed Structured Data
EIP-712 is the standard for signing typed structured data, which improves the readability of messages and helps prevent signing opaque, potentially malicious messages.

SDK Documentation

// EIP-712 Typed Data Message
// Define the EIP-712 typed data structure
const domain = {
  name: "MyDapp",
  version: "1",
  chainId: 1,
  verifyingContract: "0xYourContractAddress",
};

const types = {
  MyType: [
    { name: "sender", type: "address" },
    { name: "amount", type: "uint256" },
  ],
};

const typedDataMessage = {
  sender: "0xSenderAddress",
  amount: 1000,
};

const typedDataMessage = hashTypedData({
  domains,
  types,
  primaryType: "MyType",
  typedDataMessage,
});

let payloadSignature: PayloadSignature = await wallet.createPayloadSignature(typedDataMessage);
payloadSignature = await payloadSignature.wait();


Smart Contract Deployments
The CDP SDK supports deploying custom contracts alongside ERC-20s (fungible tokens), ERC-721s (NFTs), and ERC-1155s (MultiTokens). If you’d like to see support for additional contracts, contact us in the CDP Discord.

Agent-generated Contracts: Allow your agents to independently create and programmatically deploy smart contracts, enabling features like:
Escrow contracts
Single-use contracts for complex DeFi operations
Hyper-personalized apps
Expansive Gaming Ecosystem: Create autonomous in-game currencies and items.
NFT-based Verification for Photos: Create a camera app that mints an NFT upon photo capture to prove its provenance.
Loyalty Programs: Introduce a loyalty program for your users that can be used across your platform and on others.
AI-Generated Game Assets: Use fungible and non-fungible tokens alongside artificial intelligence to allow users to build their own characters and assets.
Examples

Tip
See supported methods at the bottom of this page for a list of all the methods supported by each contract type.

Deploying an Arbitrary Contract
To deploy an arbitrary contract, first write a Solidity smart contract, then get the contract in the input JSON format. There are three ways to do this:

Remix (web-based, recommended): Use the web-based Remix IDE to compile your Solidity contract (Ctrl + S within the .sol file), then in the file explorer navigate to the ‘build-info’ folder to find your Solidity input JSON format. Grab the first portion of the JSON file, going from line 1 to the end bracket before the “output” property.
Foundry (best for complex, production-ready contracts): In traditional smart contract development, toolchains like Foundry are great for production-ready testing and development. Foundry has a command to build and compile contracts in the JSON format:
forge build --print-compiler-input > compiler_input.json

AI-generated input JSON (simplest contracts): Have AI generate Solidity code in the input JSON format; AgentKit agents are prompted with some additional context on how to build them, and is generally accurate on simple smart contracts. Due to limitations with current models, AI may not be able to generate complex multi-file architectures.
Next, execute the following command to compile and deploy the contract:

const smartContract: SmartContract = await wallet.deployContract({ 
    solidityVersion: '0.8.28+commit.7893614a', // acceptable versions can be found at https://binaries.soliditylang.org/bin/list.json
    solidityInputJson: contractInputJson,
    contractName: "SomeContractName",
    constructorArgs: {
      param: "someValue",
      param2: "someOtherValue",
    }
});
await smartContract.wait()

The contract code will be automatically verified and available for viewing on Etherscan’s family of blockchain explorers.

Deploying an ERC-20
ERC-20 tokens are the most common type of fungible token on Ethereum. Interacting with the contract is done through the Transfer API for simple transfers, or with the invokeContract function for other calls. All standard ERC-20 functions are supported. Below is an example of how to call a deployed ERC20 contract.

Tokens can be created and interacted with by doing the following:

import { SmartContract } from "@coinbase/coinbase-sdk"

// Create a new wallet (or import an existing one)
const wallet = await Wallet.create();

// Fund the wallet manually or use the [base-sepolia faucet](./wallets.mdx#faucets)

// Deploy the token
const deployedContract: SmartContract = await wallet.deployToken({
    name: "ExampleCoin",
    symbol: "EXAM",
    totalSupply: 100000
});
await deployedContract.wait();

// Interact with the deployed contract
const approveArgs = {
    spender: "0xApprovedSpender",
    value: "10000000",
};

const contractInvocation = await wallet.invokeContract({
    contractAddress: deployedContract.getContractAddress(),
    method: "approve",
    args: approveArgs,
});
await contractInvocation.wait();

Deploying an ERC-721
ERC-721 is the standard for non-fungible tokens on Ethereum. The URI is the location of the metadata for the NFT. To properly interact with marketplaces, the URI must be a valid JSON file.

The creation and interaction process is similar to fungible tokens:

const nft = await wallet.deployNFT({
    name: "My NFT",
    symbol: "MNFT",
    baseURI: "https://my-nft-base-uri.com/metadata/",
});
await nft.wait();

// Mint 3 token to destinationAddress by calling invokeContract
const mintTx = await wallet.invokeContract({
    contractAddress: nft.getContractAddress(),
    method: "mint",
    args: {
        to: "0xDestinationAddress",
        quantity: "3",
    },
});
await mintTx.wait();

Deploying an ERC-1155
ERC-1155 is the standard for multi-token fungible tokens on Ethereum. Instead of minting one token at a time, you can mint multiple tokens in a single transaction with the same metadata. This guide explains how to define the metadata properly.

Two mint methods are supported: mint and mintBatch. mint requires a single to address and mintBatch requires an array of to addresses and an array of values of the same length.

const multiToken = await wallet.deployMultiToken({
  uri: "https://example.com/{id}.json",
});
await multiToken.wait();

const multiTokenAddress = multiToken.getContractAddress();

// Mint 1 token to destinationAddress by calling invokeContract
const mintTx = await addr.invokeContract({
  contractAddress: multiTokenAddress,
  method: "mint",
  args: {
    to: "0xDestinationAddress",
    id: "1",
    value: "1",
  },
});
await mintTx.wait();

// let's do a mintBatch
const mintBatchTx = await addr.invokeContract({
  contractAddress: multiTokenAddress,
  method: "mintBatch",
  args: {
    to: "0xDestinationAddress",
    ids: ["1", "2"],
    values: ["5", "10"],
  },
});
await mintBatchTx.wait();

Supported Methods
ERC-20 Functions
Inherits: ERC20

constructor
Constructor to initialize the ERC20 token with a name, symbol, and initial supply. The entire initial supply is assigned to the deployer of the contract.

constructor(string memory name, string memory symbol, uint256 amount) ERC20(name, symbol);

ERC-721 Functions
Inherits: ERC721AQueryable, Ownable2Step

constructor
Constructor to initialize the token with name, symbol, base URI, and deployer address

constructor(string memory name, string memory symbol, string memory baseURI)
    ERC721A(name, symbol)
    Ownable(msg.sender);

Parameters

Name
Type
Description
name
string
The name of the token
symbol
string
The symbol of the token
baseURI
string
The base URI for the token metadata

mint
Mint a single token to a specified address

Only the contract owner can call this function

function mint(address to) external onlyOwner;

Parameters

Name
Type
Description
to
address
The address to mint the token to

mint
Mint a single token to a specified address with data

Only the contract owner can call this function

function mint(address to, bytes memory data) external onlyOwner;

Parameters

Name
Type
Description
to
address
The address to mint the token to
data
bytes
The data to pass to the minted token

mint
Mint a specified quantity of tokens to a specified address

Only the contract owner can call this function

function mint(address to, uint8 quantity) external onlyOwner;

Parameters

Name
Type
Description
to
address
The address to mint tokens to
quantity
uint8
The number of tokens to mint

mint
Mint a specified quantity of tokens to a specified address with data

Only the contract owner can call this function

function mint(address to, uint8 quantity, bytes memory data) external onlyOwner;

Parameters

Name
Type
Description
to
address
The address to mint tokens to
quantity
uint8
The number of tokens to mint
data
bytes
The data to pass to the minted tokens

ERC-1155 Functions
Inherits: ERC1155Supply, Ownable2Step

constructor
Constructs an ERC1155 token with a URI, owned by the deployer of the contract

constructor(string memory uri) ERC1155(uri) Ownable(msg.sender);

Parameters

Name
Type
Description
uri
string
The URI for all the token metadata, should be of the format "https://token-cdn-domain/{id}.json"

mint
Mint a new token which can be fungible or non-fungible. Non-fungible tokens have a unique ID with a total supply of 1

function mint(address to, uint256 id, uint256 value) external onlyOwner;

Parameters

Name
Type
Description
to
address
The address to receive the minted tokens
id
uint256
The ID of the token to mint
value
uint256
The amount of tokens to mint

mint
Mint a new token which can be fungible or non-fungible. Non-fungible tokens have a unique ID with a total supply of 1

function mint(address to, uint256 id, uint256 value, bytes memory data) external onlyOwner;

Parameters

Name
Type
Description
to
address
The address to receive the minted tokens
id
uint256
The ID of the token to mint
value
uint256
The amount of tokens to mint
data
bytes
Additional data with no specified format, to be passed to the receiver contract

mintBatch
Mint a batch of new tokens which can be fungible or non-fungible. Non-fungible tokens have a unique ID with a total supply of 1

function mintBatch(address to, uint256[] memory ids, uint256[] memory values) external onlyOwner;

Parameters

Name
Type
Description
to
address
The address to receive the minted tokens
ids
uint256[]
The IDs of the tokens to mint
values
uint256[]
The amounts of tokens to mint, must be the same length as ids

mintBatch
Mint a batch of new tokens which can be fungible or non-fungible. Non-fungible tokens have a unique ID with a total supply of 1

function mintBatch(address to, uint256[] memory ids, uint256[] memory values, bytes memory data) external onlyOwner;

Parameters

Name
Type
Description
to
address
The address to receive the minted tokens
ids
uint256[]
The IDs of the tokens to mint
values
uint256[]
The amounts of tokens to mint, must be the same length as ids
data
bytes
Additional data with no specified format, to be passed to the receiver contract

Solidity Types Supported in CDP SDK
The following table explains how the CDP SDK handles different Solidity types. For support with other Solidity types, contact us in the #wallet-api channel of the CDP Discord.

Solidity Type
Parameter Argument
Example
int8, int16, int32, int64, int128, int256
string
"-42"
uint8, uint16, uint32, uint64, uint128, uint256
string
"123456"
function
hex-encoded string (4-byte array)
"0xa9059cbb"
bool
boolean
true
bytes
hex-encoded string
"0x1234abcd"
fixed bytes (e.g., bytes32)
hex-encoded string (fixed length)
"0x000000000000000000000000a0b82847ab218b36c1d19d4a2e9eb0ce3606eb48"
string
string
"Hello, World!"
address
hex-encoded string
"0xBe9895146f7AF43049ca1c1AE358B0541Ea49704"
arrays
array with elements following type rules
["1", "2", "3"]
tuple
array of tuple fields
["John Doe", "25", "0xBe9895146f7AF43049ca1c1AE358B0541Ea49704"]



Smart Wallets
A Smart Wallet is an ERC-4337 compatible account abstraction wallet. The Smart Wallet API uses the same smart contract as the Frontend SDK. This new feature is currently in beta.

The Wallet API supports creation of SmartWallets as a backend wallet, offering features like paymaster for sponsoring gas and batch transactions.


Note
If you are interested in using SmartWallet for your users in your frontend application, navigate to the Frontend SDK instead.

A Smart Wallet is a single address that works across EVM networks. For now, only Base Mainnet and Base Sepolia are supported. As we introduce new networks, existing SmartWallets will have the same address and be automatically supported.

A SmartWallet has a single owner, which is the account backed by a private key that signs transactions for the wallet. Think of a private key as the password to a wallet. For more, see What is a private key?.

Creating a Smart Wallet
We recommend using Viem to create the private key and owner account of the SmartWallet.

Refer to the SmartWallet SDK docs for a full list of supported methods.

import { generatePrivateKey, privateKeyToAccount } from "viem/accounts";
import { createSmartWallet } from "@coinbase/coinbase-sdk";
import { Coinbase } from "@coinbase/coinbase-sdk";

// This key must be stored securely and persisted across sessions! See Securing a Smart Wallet below for more information.
const privateKey = generatePrivateKey();
const owner = privateKeyToAccount(privateKey);
const smartWallet = await createSmartWallet({
    signer: owner
});
// Get the smart wallet address
const smartWalletAddress = smartWallet.address;

Sending a User operation
A UserOperation is used to execute transactions through a Smart Wallet, using account abstraction to enable features like batch transactions and sponsored gas fees without needing a traditional EOA wallet.

sendUserOperation is how you send operations for the SmartWallet. It supports batch transactions and paymaster for sponsoring.

For more on Paymaster, see the Paymaster docs.

You can either provide an ABI and the function to call, or the encoded function data. The next example demonstrates a batch transaction that sends ETH to a destination address and calls a function on a contract.

const smartWallet = await createSmartWallet({
    signer: owner
});
const ABI = [
  {
    inputs: [
      { internalType: "uint256", name: "a", type: "uint256" },
      { internalType: "bool", name: "b", type: "bool" },
      { internalType: "address", name: "c", type: "address" },
    ],
    name: "someFunction",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function",
  },
] as const; // This "as const" is very important!

const userOperation = await smartWallet.sendUserOperation({
  calls: [
    {
      to: "0x1234567890123456789012345678901234567890",
      value: parseEther("0.0000005"),
      data: "0x",
    },
    {
      to: "0xb720E683CB90838F23F66a37Adb26c24e04D1b60",
      abi: ABI,
      functionName: "someFunction",
      args: [123n, true, "0x3234567890123456789012345678901234567890"],
    },
  ],
  chainId: 84532,
});

const userOperationResult = await waitForUserOperation(userOperation);
// You can now use the result to see the status and get the transactionHash if it was successful.

For ABIs, make sure to include as const as this is needed by Typescript for proper compilation.

Paymaster
For Base Sepolia, the CDP API automatically sponsors gas for the SmartWallet, so you don't need any gas to send user operations! For Base Mainnet, you can pass in a Paymaster URL to the sendUserOperation function to sponsor the gas for the operation.

Check out the Paymaster docs for more information and getting started with your own Paymaster.

const userOperation = await smartWallet.sendUserOperation({
    calls: [
        {
            to: "0x1234567890123456789012345678901234567890",
            value: parseEther("0.0000005"), 
            data: "0x",
        },
    ],
    chainId: 8453,
    paymasterURL: "https://api.developer.coinbase.com/rpc/v1/base/someapikey",
});

Securing a Smart Wallet
The private key for the owner account must be securely stored. It is your responsibility as the developer to securely store this key. For example, you may choose to store this data in an encrypted database.


Secure your Private Key
Losing the private key for the owner of the SmartWallet could result in a loss of funds. Please take all necessary precautions to secure this key.

Persisting Locally
Here's an example of how to store a private key locally.

To save your private key, run the following:

import fs from "fs";

// create a smart wallet with viem wallet owner
const privateKey = generatePrivateKey();
const owner = privateKeyToAccount(privateKey);
const smartWallet = await createSmartWallet({ signer: owner });

// persist the privateKey and persist the smartWallet address
fs.writeFileSync("privateKey.txt", privateKey);
fs.writeFileSync("smartWalletAddress.txt", smartWallet.address);

In production, developers should encrypt the private key!


Warning
This is an insecure method of storing private keys and should only be used for development purposes.

Re-instantiating a Smart Wallet
The private key and the smart wallet address are required to re-instantiate a wallet when a new session is started.

The following code demonstrates how to import the data required to re-instantiate a wallet.

import fs from "fs";
import { privateKeyToAccount } from "viem/accounts";
import { toSmartWallet } from "@coinbase/coinbase-sdk";

const privateKey = fs.readFileSync("privateKey.txt", "utf8");
const owner = privateKeyToAccount(privateKey as `0x${string}`);
const smartWalletAddress = fs.readFileSync("smartWalletAddress.txt", "utf8") as `0x${string}`;
const smartWallet = toSmartWallet({ smartWalletAddress, signer: owner });

You can now use the smartWallet for all your operations.


Get Started with Smart Wallet
Smart Wallet is a multi-chain self-custodial cryptocurrency wallet. It enables users to create an account in seconds with no app or extension required, thanks to its reliance on Passkeys.

This simple guide provides three options for getting started with Smart Wallet:

Quick Demo using OnchainKit (5 mins) - The fastest way to see Smart Wallet in action
Add to Existing Next.js Project (15 mins) - Step-by-step integration with an existing Next.js application using Wagmi
Add to Existing React Native Project - A detailed guide for adding Smart Wallet to an existing React Native project


# Add to Existing Next.js Project (with Wagmi)

This option guides you through adding Smart Wallet to an existing
[Next.js](https://nextjs.org/) application using [Wagmi](https://wagmi.sh/).

## Step 1: Install Dependencies

Let's start by navigating to your project directory and installing the dependencies:

<CodeGroup>
  ```bash npm
  npm install @coinbase/wallet-sdk wagmi viem @tanstack/react-query
  ```

  ```bash pnpm
  pnpm add @coinbase/wallet-sdk wagmi viem @tanstack/react-query
  ```

  ```bash yarn
  yarn add @coinbase/wallet-sdk wagmi viem @tanstack/react-query
  ```

  ```bash bun
  bun add @coinbase/wallet-sdk wagmi viem @tanstack/react-query
  ```
</CodeGroup>

## Step 2: Create Wagmi Config

If your project does not have a Wagmi Config, create a file called `wagmi.ts` in the root directory of your project:

```typescript
import { http, createConfig } from "wagmi";
import { baseSepolia } from "wagmi/chains";
import { coinbaseWallet } from "wagmi/connectors";

export const cbWalletConnector = coinbaseWallet({
  appName: "Wagmi Smart Wallet",
  preference: "smartWalletOnly",
});

export const config = createConfig({
  chains: [baseSepolia],
  // turn off injected provider discovery
  multiInjectedProviderDiscovery: false,
  connectors: [cbWalletConnector],
  ssr: true,
  transports: {
    [baseSepolia.id]: http(),
  },
});

declare module "wagmi" {
  interface Register {
    config: typeof config;
  }
}
```

<Note>
  The wagmi config is modified to include the Smart Wallet connector `cbWalletConnector`.
</Note>

## Step 3: Create Providers Component

Create a file called `providers.tsx` in your `app/` directory:

```tsx
"use client";

import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useState, type ReactNode } from "react";
import { WagmiProvider } from "wagmi";

import { config } from "@/wagmi";

export function Providers(props: { children: ReactNode }) {
  const [queryClient] = useState(() => new QueryClient());

  return (
    <WagmiProvider config={config}>
      <QueryClientProvider client={queryClient}>
        {props.children}
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

## Step 4: Add Providers to Root Layout

Update your root layout file (`app/layout.tsx`):

```tsx
import "./globals.css";
import type { Metadata } from "next";
import type { ReactNode } from "react";

import { Providers } from "./providers";

export const metadata: Metadata = {
  title: "Smart Wallet App",
  description: "Smart Wallet Next.js integration",
};

export default function RootLayout(props: { children: ReactNode }) {
  return (
    <html lang="en">
      <body>
        <Providers>{props.children}</Providers>
      </body>
    </html>
  );
}
```

## Step 5: Create `ConnectAndSIWE` Component

Create a component for wallet connection and Sign-In With Ethereum (SIWE):

```tsx
import { useCallback, useEffect, useState } from "react";
import type { Hex } from "viem";
import { useAccount, useConnect, usePublicClient, useSignMessage } from "wagmi";
import { SiweMessage } from "siwe";
import { cbWalletConnector } from "@/wagmi";

export function ConnectAndSIWE() {
  const { connect } = useConnect({
    mutation: {
      onSuccess: (data) => {
        const address = data.accounts[0];
        const chainId = data.chainId;
        const m = new SiweMessage({
          domain: document.location.host,
          address,
          chainId,
          uri: document.location.origin,
          version: "1",
          statement: "Smart Wallet SIWE Example",
          nonce: "12345678",
        });
        setMessage(m);
        signMessage({ message: m.prepareMessage() });
      },
    },
  });
  const account = useAccount();
  const client = usePublicClient();
  const [signature, setSignature] = useState<Hex | undefined>(undefined);
  const { signMessage } = useSignMessage({
    mutation: { onSuccess: (sig) => setSignature(sig) },
  });
  const [message, setMessage] = useState<SiweMessage | undefined>(undefined);

  const [valid, setValid] = useState<boolean | undefined>(undefined);

  const checkValid = useCallback(async () => {
    if (!signature || !account.address || !client || !message) return;

    client
      .verifyMessage({
        address: account.address,
        message: message.prepareMessage(),
        signature,
      })
      .then((v) => setValid(v));
  }, [signature, account]);

  useEffect(() => {
    checkValid();
  }, [signature, account]);

  useEffect(() => {});

  return (
    <div>
      <button onClick={() => connect({ connector: cbWalletConnector })}>
        Connect + SIWE
      </button>
      <p>{}</p>
      {valid != undefined && <p> Is valid: {valid.toString()} </p>}
    </div>
  );
}
```

## Step 6: Use the Component in a Page

Add the component to `app/page.tsx`:

```tsx
import { ConnectAndSIWE } from '../components/ConnectAndSIWE'

export default function Home() {
  return (
    <main>
      <h1>Smart Wallet Integration</h1>
      <ConnectAndSIWE />
    </main>
  )
}
```

<Check>
  Congratulations! You just integrated Smart Wallet in your app.
  You can now [Explore More Features](/smart-wallet/quickstart#explore-more-features).
</Check>
