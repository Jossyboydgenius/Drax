COINBASE x403 DOCS

Welcome to x402
This guide will help you understand x402, the open payment standard, and help you get started building or integrating services with x402.

x402 is the open payment standard that enables services to charge for access to their APIs and content directly over HTTP. It is built around the HTTP 402 Payment Required status code and allows clients to programmatically pay for resources without accounts, sessions, or credential management.

With x402, any web service can require payment before serving a response, using crypto-native payments for speed, privacy, and efficiency.

Why Use x402?
x402 addresses key limitations of existing payment systems:

High fees and friction with traditional credit cards and fiat payment processors

Incompatibility with machine-to-machine payments, such as AI agents

Lack of support for micropayments, making it difficult to monetize usage-based services

Who is x402 for?
Sellers: Service providers who want to monetize their APIs or content. x402 enables direct, programmatic payments from clients with minimal setup.

Buyers: Human developers and AI agents seeking to access paid services without accounts or manual payment flows.

Both sellers and buyers interact directly through HTTP requests, with payment handled transparently through the protocol.

What Can You Build?
x402 enables a range of use cases, including:

API services paid per request

AI agents that autonomously pay for API access

Paywalls for digital content

Microservices and tooling monetized via microtransactions

Proxy services that aggregate and resell API capabilities

How Does It Work?
At a high level, the flow is simple:

A buyer requests a resource from a server.

If payment is required, the server responds with 402 Payment Required, including payment instructions.

The buyer prepares and submits a payment payload.

The server verifies and settles the payment using an x402 facilitator's /verify and /settle endpoints.

If payment is valid, the server provides the requested resource.



Quickstart for Buyers
This guide walks you through how to use x402 to interact with services that require payment. By the end of this guide, you will be able to programmatically discover payment requirements, complete a payment, and access a paid resource.

Prerequisites
Before you begin, ensure you have:

A crypto wallet with USDC (any EVM-compatible wallet, e.g., CDP Wallet)

Node.js and npm installed

A service that requires payment via x402

Note
We have pre-configured examples available in our repo, including examples for fetch, Axios, and MCP.

1. Install Dependencies
Install x402-axios or x402-fetch:

Copy
npm install x402-axios
# or
npm install x402-fetch
2. Create a Wallet Client
Create a wallet client using CDP's Wallet API or viem: 

Viem
CDP Wallet API
Copy
import { createWalletClient, http } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { baseSepolia } from "viem/chains";

// Create a wallet client (using your private key)
const account = privateKeyToAccount("0xYourPrivateKey"); // we recommend using an environment variable for this
3. Make Paid Requests Automatically
You can use either x402-fetch or x402-axios to automatically handle 402 Payment Required responses and complete payment flows.

Fetch
Axios
x402-fetch extends the native fetch API to handle 402 responses and payment headers for you.

Copy
import { wrapFetchWithPayment, decodeXPaymentResponse } from "x402-fetch";

const fetchWithPayment = wrapFetchWithPayment(fetch, account);

fetchWithPayment(url, { //url should be something like https://api.example.com/paid-endpoint
  method: "GET",
})
  .then(async response => {
    const body = await response.json();
    console.log(body);

    const paymentResponse = decodeXPaymentResponse(response.headers.get("x-payment-response")!);
    console.log(paymentResponse);
  })
  .catch(error => {
    console.error(error.response?.data?.error);
  });
Features:

Automatically handles 402 Payment Required responses

Verifies payment and generates payment headers

Retries the request with proof of payment

Supports all standard fetch options

4. Error Handling
Both x402-fetch and x402-axios will throw errors if:

The request configuration is missing

A payment has already been attempted for the request

There is an error creating the payment header

Summary
Install either x402-fetch or x402-axios

Create a wallet client (using viem or CDP Wallet API)

Use the provided wrapper/interceptor to make paid API requests

Payment flows are handled automatically for you




Quickstart for Sellers
This guide walks you through integrating with x402 to enable payments for your API or service. By the end, your API will be able to charge buyers and AI agents for access.

Prerequisites
Before you begin, ensure you have:

A crypto wallet to receive funds (any EVM-compatible wallet, e.g., CDP Wallet)

(optional) A Coinbase Developer Platform (CDP) account and API Keys

Required for mainnet use until other facilitators go live

Node.js and npm installed

An existing API or server

Note
We have pre-configured examples available in our repo, including examples for Express, Next.js, and Hono. We also have an advanced example that shows how to use the x402 SDKs to build a more complex payment flow.

1. Install Dependencies
Express
Next.js
Hono
Install the x402 Express middleware package.

Copy
npm install x402-express
npm install @coinbase/x402 # for the mainnet facilitator
2. Add Payment Middleware
Integrate the payment middleware into your application. You will need to provide:

The Facilitator URL or facilitator object. For testing, use https://x402.org/facilitator which works on Base Sepolia. For mainnet, you can use the facilitator from @coinbase/x402.

For more information on running in production on mainnet, check out CDP's Quickstart for Sellers

The routes you want to protect.

Your receiving wallet address.

Express
Next.js
Hono
Full example in the repo here.

Copy
import express from "express";
import { paymentMiddleware, Network } from "x402-express";

const app = express();

app.use(paymentMiddleware(
  "0xYourAddress", // your receiving wallet address 
  {  // Route configurations for protected endpoints
      "GET /weather": {
        // USDC amount in dollars
        price: "$0.001",
        network: "base-sepolia",
      },
    },
  {
    url: "https://x402.org/facilitator", // Facilitator URL for Base Sepolia testnet. 
  }
));

// Implement your route
app.get("/weather", (req, res) => {
  res.send({
    report: {
      weather: "sunny",
      temperature: 70,
    },
  });
});

app.listen(4021, () => {
  console.log(`Server listening at http://localhost:4021`);
});
This is the interface for the payment middleware config:

Copy
interface PaymentMiddlewareConfig {
  description?: string;               // Description of the payment
  mimeType?: string;                  // MIME type of the resource
  maxTimeoutSeconds?: number;         // Maximum time for payment (default: 60)
  outputSchema?: Record; // JSON schema for the response
  customPaywallHtml?: string;         // Custom HTML for the paywall
  resource?: string;                  // Resource URL (defaults to request URL)
}
When a request is made to this route without payment, your server will respond with the HTTP 402 Payment Required code and payment instructions.

3. Test Your Integration
To verify:

Make a request to your endpoint (e.g., curl http://localhost:3000/your-endpoint).

The server responds with a 402 Payment Required, including payment instructions in the body.

Complete the payment using a compatible client, wallet, or automated agent. This typically involves signing a payment payload, which is handled by the client SDK detailed in the Quickstart for Buyers.

Retry the request, this time including the X-PAYMENT header containing the cryptographic proof of payment (payment payload).

The server verifies the payment via the facilitator and, if valid, returns your actual API response (e.g., { "data": "Your paid API response." }).

4. Error Handling
If you get an error stating Cannot find module 'x402-hono/express' or its corresponding type declarations., add the tsconfig.json from the Hono example to your project.

npm install the dependencies in each example


Summary
This quickstart covered:

Installing the x402 SDK and relevant middleware

Adding payment middleware to your API and configuring it

Testing your integration

Your API is now ready to accept crypto payments through x402.


HTTP 402
For decades, HTTP 402 Payment Required has been reserved for future use. x402 unlocks it, and absolves the internet of its original sin.

What is HTTP 402?
HTTP 402 is a standard, but rarely used, HTTP response status code indicating that payment is required to access a resource.

In x402, this status code is activated to:

Inform clients (buyers or agents) that payment is required.

Communicate the details of the payment, such as amount, currency, and destination address.

Provide the information necessary to complete the payment programmatically.

Why x402 Uses HTTP 402
The primary purpose of HTTP 402 is to enable frictionless, API-native payments for accessing web resources, especially for:

Machine-to-machine (M2M) payments (e.g., AI agents).

Pay-per-use models such as API calls or paywalled content.

Micropayments without account creation or traditional payment rails.

Using the 402 status code keeps x402 protocol natively web-compatible and easy to integrate into any HTTP-based service.

Summary
HTTP 402 is the foundation of the x402 protocol, enabling services to declare payment requirements directly within HTTP responses. It:

Signals payment is required

Communicates necessary payment details

Integrates seamlessly with standard HTTP workflows


Client / Server
This page explains the roles and responsibilities of the client and server in the x402 protocol.

Understanding these roles is essential to designing, building, or integrating services that use x402 for programmatic payments.

Note
Client refers to the technical component making an HTTP request. In practice, this is often the buyer of the resource.

Server refers to the technical component responding to the request. In practice, this is typically the seller of the resource

Client Role
The client is the entity that initiates a request to access a paid resource.

Clients can include:

Human-operated applications

Autonomous agents

Programmatic services acting on behalf of users or systems

Responsibilities
Initiate requests: Send an HTTP request to the resource server.

Handle payment requirements: Read the 402 Payment Required response and extract payment details.

Prepare payment payload: Use the provided payment requirements to construct a valid payment payload.

Resubmit request with payment: Retry the request with the X-PAYMENT header containing the signed payment payload.

Clients do not need to manage accounts, credentials, or session tokens beyond their crypto wallet. All interactions are stateless and occur over standard HTTP requests.

Server Role
The server is the resource provider enforcing payment for access to its services.

Servers can include:

API services

Content providers

Any HTTP-accessible resource requiring monetization

Responsibilities
Define payment requirements: Respond to unauthenticated requests with an HTTP 402 Payment Required, including all necessary payment details in the response body.

Verify payment payloads: Validate incoming payment payloads, either locally or by using a facilitator service.

Settle transactions: Upon successful verification, submit the payment for settlement.

Provide the resource: Once payment is confirmed, return the requested resource to the client.

Servers do not need to manage client identities or maintain session state. Verification and settlement are handled per request.

Communication Flow
The typical flow between a client and a server in the x402 protocol is as follows:

Client initiates request to the server for a paid resource.

Server responds with 402 Payment Required, including the payment requirements in the response body.

Client prepares and submits a payment payload based on the provided requirements.

Server verifies the payment payload, either locally or through a facilitator service.

Server settles the payment and confirms transaction completion.

Server responds with the requested resource, assuming payment was successful.

Summary
In the x402 protocol:

The client requests resources and supplies the signed payment payload.

The server enforces payment requirements, verifies transactions, and provides the resource upon successful payment.

This interaction is stateless, HTTP-native, and compatible with both human applications and automated agents.

Next, explore:

Facilitator — how servers verify and settle payments

HTTP 402 — how servers communicate payment requirements to clients


Facilitator
This page explains the role of the facilitator in the x402 protocol.

The facilitator is an optional but recommended service that simplifies the process of verifying and settling payments between clients (buyers) and servers (sellers).

What is a Facilitator?
The facilitator is a service that:

Verifies payment payloads submitted by clients.

Settles payments on the blockchain on behalf of servers.

By using a facilitator, servers do not need to maintain direct blockchain connectivity or implement payment verification logic themselves. This reduces operational complexity and ensures accurate, real-time validation of transactions.

Facilitator Responsibilities
Verify payments: Confirm that the client's payment payload meets the server's declared payment requirements.

Settle payments: Submit validated payments to the blockchain and monitor for confirmation.

Provide responses: Return verification and settlement results to the server, allowing the server to decide whether to fulfill the client's request.

The facilitator does not hold funds or act as a custodian - it performs verification and execution of onchain transactions based on signed payloads provided by clients.

Why Use a Facilitator?
Using a facilitator provides:

Reduced operational complexity: Servers do not need to interact directly with blockchain nodes.

Protocol consistency: Standardized verification and settlement flows across services.

Faster integration: Services can start accepting payments with minimal blockchain-specific development.

While it is possible to implement verification and settlement locally, using a facilitator accelerates adoption and ensures correct protocol behavior.

Live Facilitators
Currently, CDP hosts the only facilitator live on Base mainnet. For more information about getting started, see the CDP Docs.

CDP's facilitator offers fee-free USDC settlement on Base mainnet

As more facilitators go live, we will include them here.

Interaction Flow
Client makes an HTTP request to a resource server

Resource server responds with a 402 Payment Required status and a Payment Required Response JSON object in the response body.

Client selects one of the paymentDetails returned by the accepts field of the server response and creates a Payment Payload based on the scheme of the paymentDetails they have selected.

Client sends the HTTP request with the X-PAYMENT header containing the Payment Payload to the resource server

Resource server verifies the Payment Payload is valid either via local verification or by POSTing the Payment Payload and Payment Details to the /verify endpoint of the facilitator server.

Facilitator server performs verification of the object based on the scheme and networkId of the Payment Payload and returns a Verification Response

If the Verification Response is valid, the resource server performs the work to fulfill the request. If the Verification Response is invalid, the resource server returns a 402 Payment Required status and a Payment Required Response JSON object in the response body.

Resource server either settles the payment by interacting with a blockchain directly, or by POSTing the Payment Payload and Payment Details to the /settle endpoint of the facilitator server.

Facilitator server submits the payment to the blockchain based on the scheme and networkId of the Payment Payload.

Facilitator server waits for the payment to be confirmed on the blockchain.

Facilitator server returns a Payment Execution Response to the resource server.

Resource server returns a 200 OK response to the Client with the resource they requested as the body of the HTTP response, and a X-PAYMENT-RESPONSE header containing the Settlement Response as Base64 encoded JSON if the payment was executed successfully.

Summary
The facilitator acts as an independent verification and settlement layer within the x402 protocol. It helps servers confirm payments and submit transactions onchain without requiring direct blockchain infrastructure.

Next, explore:

Client / Server — understand the roles and responsibilities of clients and servers

HTTP 402 — understand how payment requirements are communicated to clients


Wallet
This page explains the role of the wallet in the x402 protocol.

In x402, a wallet is both a payment mechanism and a form of unique identity for buyers and sellers. Wallet addresses are used to send, receive, and verify payments, while also serving as identifiers within the protocol.

Role of the Wallet
For Buyers
Buyers use wallets to:

Store USDC/crypto

Sign payment payloads

Authorize onchain payments programmatically

Wallets enable buyers, including AI agents, to transact without account creation or credential management.

For Sellers
Sellers use wallets to:

Receive USDC/crypto payments

Define their payment destination within server configurations

A seller's wallet address is included in the payment requirements provided to buyers.

CDP's Wallet API is our recommended option for programmatic payments and secure key management.

Summary
Wallets enable programmatic, permissionless payments in x402.

Buyers use wallets to pay for services.

Sellers use wallets to receive payments.

Wallet addresses also act as unique identifiers within the protocol.



MCP Server with x402
Model Context Protocol (MCP) is a protocol for passing context between LLMs and other AI agents. This page shows how to use the x402 payment protocol with MCP to make paid API requests through an MCP server, and how to connect it to Claude Desktop.

What is this integration?
This guide walks you through running an MCP server that can access paid APIs using the x402 protocol. The MCP server acts as a bridge between Claude Desktop (or any MCP-compatible client) and a paid API (such as the sample weather API in the x402 repo). When Claude (or another agent) calls a tool, the MCP server will:

Detect if the API requires payment (via HTTP 402)

Automatically handle the payment using your wallet

Return the paid data to the client (e.g., Claude)

This lets you (or your agent) access paid APIs programmatically, with no manual payment steps.

Prerequisites
Node.js (v20 or higher)

An x402-compatible server to connect to (for this demo, we'll use the sample express server with weather data from the x402 repo, or any external x402 API)

An Ethereum wallet with USDC (on Base Sepolia or Base Mainnet)

Claude Desktop with MCP support

Step-by-Step: Build the MCP + x402 Integration
You can find a ready-to-use version of this code in the x402 repo. Below, we explain each step so you understand how it works and can adapt it to your needs.

1. Install Dependencies
Copy
npm install @modelcontextprotocol/sdk axios viem x402-axios dotenv
2. Set Up Environment Variables
Create a .env file in your project root:

Copy
PRIVATE_KEY=0xYourTestnetPrivateKey
RESOURCE_SERVER_URL=http://localhost:4021
ENDPOINT_PATH=/weather
PRIVATE_KEY: Your EVM wallet's private key (for signing payments)

RESOURCE_SERVER_URL: The base URL of the paid API (use the sample express server for this demo)

ENDPOINT_PATH: The specific endpoint path (e.g., /weather)

3. Implementation: MCP Server with x402 Payments
Copy
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import axios from "axios";
import { Hex } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { withPaymentInterceptor } from "x402-axios";
import { config } from "dotenv";

// Load environment variables and throw an error if any are missing
config();

const privateKey = process.env.PRIVATE_KEY as Hex;
const baseURL = process.env.RESOURCE_SERVER_URL as string; // e.g. https://example.com
const endpointPath = process.env.ENDPOINT_PATH as string; // e.g. /weather

if (!privateKey || !baseURL || !endpointPath) {
  throw new Error("Missing environment variables");
}

// Create a wallet client to handle payments
const account = privateKeyToAccount(privateKey);

// Create an axios client with payment interceptor using x402-axios
const client = withPaymentInterceptor(axios.create({ baseURL }), account);

// Create an MCP server
const server = new McpServer({
  name: "x402 MCP Client Demo",
  version: "1.0.0",
});


// Add an addition tool
server.tool(
  "get-data-from-resource-server",
  "Get data from the resource server (in this example, the weather)", //change this description to change when the client calls the tool
  {},
  async () => {
    const res = await client.get(endpointPath);
    return {
      content: [{ type: "text", text: JSON.stringify(res.data) }],
    };
  },
);

const transport = new StdioServerTransport();
await server.connect(transport);
How it works

The MCP server exposes a tool that, when called, fetches data from a paid API endpoint.

If the endpoint requires payment, the x402-axios interceptor handles the payment handshake using your wallet.

Once payment is complete, the data is returned to the MCP client (e.g., Claude Desktop).

Add the MCP Server to Claude Desktop
To use this integration with Claude Desktop:

Open Claude Desktop and go to MCP settings.

Add a new MCP server with the following config (adjust paths as needed):

Copy
{
  "mcpServers": {
    "demo": {
      "command": "pnpm",
      "args": [
        "--silent",
        "-C",
        "<absolute path to this repo>/examples/typescript/clients/mcp",
        "dev"
      ],
      "env": {
        "PRIVATE_KEY": "<private key of a wallet with USDC on Base Sepolia>",
        "RESOURCE_SERVER_URL": "http://localhost:4021",
        "ENDPOINT_PATH": "/weather"
      }
    }
  }
}
Make sure your x402-compatible server (e.g., the sample express server) is running and accessible at the URL you provided.

Start the MCP client (e.g., with pnpm dev in the client directory).

Claude can now call the tool and receive paid data!

How the Pieces Fit Together
x402-compatible server: Hosts the paid API (e.g., weather data). Responds with HTTP 402 if payment is required.

MCP server (this implementation): Acts as a bridge, handling payment and exposing tools to MCP clients.

Claude Desktop: Calls the MCP tool, receives the paid data, and displays it to the user.

Next Steps
See the full example in the repo

Try integrating with your own x402-compatible APIs

Extend the MCP server with more tools or custom logic as needed

Welcome to x402
Overview
x402 is a new open payment protocol developed by Coinbase that enables instant, automatic stablecoin payments directly over HTTP.

By reviving the HTTP 402 Payment Required status code, x402 lets services monetize APIs and digital content onchain, allowing clients, both human and machine, to programmatically pay for access without accounts, sessions, or complex authentication.

Who is x402 for?
Sellers: Service providers who want to monetize their APIs or content. x402 enables direct, programmatic payments from clients with minimal setup.
Buyers: Human developers and AI agents seeking to access paid services without accounts or manual payment flows.
Both sellers and buyers interact directly through HTTP requests, with payment handled transparently through the protocol.

Use cases
x402 enables a range of use cases, including:

API services paid per request
AI agents that autonomously pay for API access
Paywalls for digital content
Microservices and tooling monetized via microtransactions
Proxy services that aggregate and resell API capabilities
How it works
The buyer requests a resource from the server (see Client/Server documentation for more details)
If payment is required, the server responds with a 402 Payment Required, including payment instructions.
The buyer constructs and sends a payment payload.
The server verifies and settles the payment via the x402 facilitator’s /verify and /settle endpoints. 1.If the payment is valid, the server returns the requested resource.
Beyond legacy limitations
x402 is designed for a modern internet economy, solving key limitations of legacy systems:

Reduce fees and friction: Direct onchain payments without intermediaries, high fees, or manual setup.
Micropayments & usage-based billing: Charge per call or feature with simple, programmable pay-as-you-go flows.
Machine-to-machine transactions: Let AI agents pay and access services autonomously with no keys or human input needed.
In short, x402 lets the web transact funds as seamlessly as it shares data: instantly, globally, and natively.

Offload your infra
The x402 Facilitator handles payment verification and settlement so that sellers don't need to maintain their own blockchain infrastructure.

The Coinbase Developer Platform (CDP) offers a Coinbase-hosted facilitator service that processes fee-free USDC payments on the Base network, offering a streamlined and predictable experience for both buyers and sellers.

Facilitators handle verification and settlement, so sellers do not need to maintain blockchain infrastructure.

CDP's x402 facilitator provides:

Fee-free USDC payments on the Base network
Fast, onchain settlement of transactions
Simplified setup for sellers to start accepting payments
Facilitator roadmap
CDP's x402 facilitator is designed as a facilitator on top of an open standard, which is not tied to any single provider. Over time, the facilitator will include:

A discovery layer for buyers (human and agents) to find available services
Support for additional payment flows (e.g., pay for work done, credit based billing, etc.)
Optional attestations for sellers to enforce KYC or geographic restrictions
Support for additional assets and networks
The goal is to make programmatic commerce accessible, permissionless, and developer-friendly.


x402 MCP Example Client
This is an example client that demonstrates how to use the x402 payment protocol with the Model Context Protocol (MCP) to make paid API requests through an MCP server.

Prerequisites
Node.js v20+ (install via nvm)
pnpm v10 (install via pnpm.io/installation)
A running x402 server (you can use the example express server at examples/typescript/servers/express)
A valid Ethereum private key for making payments
Claude Desktop with MCP support
Setup
Install and build all packages from the typescript examples root:
cd ../../
pnpm install
pnpm build
cd clients/mcp
Copy .env-local to .env and add your Ethereum private key:
cp .env-local .env
Configure Claude Desktop MCP settings:
{
  "mcpServers": {
    "demo": {
      "command": "pnpm",
      "args": [
        "--silent",
        "-C",
        "<absolute path to this repo>/examples/typescript/clients/mcp",
        "dev"
      ],
      "env": {
        "PRIVATE_KEY": "<private key of a wallet with USDC on Base Sepolia>",
        "RESOURCE_SERVER_URL": "http://localhost:4021",
        "ENDPOINT_PATH": "/weather"
      }
    }
  }
}
Start the example client (remember to be running a server or pointing to one in the .env file):
pnpm dev
How It Works
The example demonstrates how to:

Create a wallet client using viem
Set up an MCP server with x402 payment handling
Create a tool that makes paid API requests
Handle responses and errors through the MCP protocol
Example Code
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import axios from "axios";
import { createWalletClient, Hex, http, publicActions } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { baseSepolia } from "viem/chains";
import { withPaymentInterceptor } from "x402-axios";

// Create wallet client
const wallet = createWalletClient({
  chain: baseSepolia,
  transport: http(),
  account: privateKeyToAccount(PRIVATE_KEY as Hex),
}).extend(publicActions);

// Create Axios instance with payment handling
const client = withPaymentInterceptor(axios.create({ baseURL: RESOURCE_SERVER_URL }), wallet);

// Create MCP server
const server = new McpServer({
  name: "x402 MCP Client Demo",
  version: "1.0.0",
});

// Add tool for making paid requests
server.tool("get-data-from-resource-server", "Get data from the resource server (in this example, the weather)",  {}, async () => {
  const res = await client.post(`${ENDPOINT_PATH}`);
  return {
    content: [{ type: "text", text: JSON.stringify(res.data) }],
  };
});

// Connect to MCP transport
const transport = new StdioServerTransport();
await server.connect(transport);
Response Handling
Payment Required (402)
When a payment is required, the MCP server will:

Receive the 402 response
Parse the payment requirements
Create and sign a payment header
Automatically retry the request with the payment header
Successful Response
After payment is processed, the MCP server will return the response data through the MCP protocol:

{
  "content": [
    {
      "type": "text",
      "text": "{\"report\":{\"weather\":\"sunny\",\"temperature\":70}}"
    }
  ]
}
Extending the Example
To use this pattern in your own application:

Install the required dependencies:
npm install @modelcontextprotocol/sdk x402-axios viem
Set up your environment variables
Create a wallet client
Set up your MCP server with x402 payment handling
Define your tools for making paid requests
Connect to the MCP transport
Integration with Claude Desktop
This example is designed to work with Claude Desktop's MCP support. The MCP server will:

Listen for tool requests from Claude
Handle the payment process automatically
Return the response data through the MCP protocol
Allow Claude to process and display the results


/**
 * Need:
 * - MCP server to be able to verify token (SSE should be able to do this)
 * - Need client to be able to send header
 * - Each client application would need to implement a wallet type
 */

import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import axios from "axios";
import { config } from "dotenv";
import { Hex } from "viem";
import { privateKeyToAccount } from "viem/accounts";
import { withPaymentInterceptor } from "x402-axios";

config();

const privateKey = process.env.PRIVATE_KEY as Hex;
const baseURL = process.env.RESOURCE_SERVER_URL as string; // e.g. https://example.com
const endpointPath = process.env.ENDPOINT_PATH as string; // e.g. /weather

if (!privateKey || !baseURL || !endpointPath) {
  throw new Error("Missing environment variables");
}

const account = privateKeyToAccount(privateKey);

const client = withPaymentInterceptor(axios.create({ baseURL }), account);

// Create an MCP server
const server = new McpServer({
  name: "x402 MCP Client Demo",
  version: "1.0.0",
});

// Add an addition tool
server.tool(
  "get-data-from-resource-server",
  "Get data from the resource server (in this example, the weather)",
  {},
  async () => {
    const res = await client.get(endpointPath);
    return {
      content: [{ type: "text", text: JSON.stringify(res.data) }],
    };
  },
);

const transport = new StdioServerTransport();
await server.connect(transport);


SERVERS:
import { config } from "dotenv";
import express from "express";
import { paymentMiddleware, Resource } from "x402-express";
config();

const facilitatorUrl = process.env.FACILITATOR_URL as Resource;
const payTo = process.env.ADDRESS as `0x${string}`;

if (!facilitatorUrl || !payTo) {
  console.error("Missing required environment variables");
  process.exit(1);
}

const app = express();

app.use(
  paymentMiddleware(
    payTo,
    {
      "GET /weather": {
        // USDC amount in dollars
        price: "$0.001",
        // network: "base" // uncomment for Base mainnet
        network: "base-sepolia",
      },
      "/premium/*": {
        // Define atomic amounts in any EIP-3009 token
        price: {
          amount: "100000",
          asset: {
            address: "0xabc",
            decimals: 18,
            eip712: {
              name: "WETH",
              version: "1",
            },
          },
        },
        // network: "base" // uncomment for Base mainnet
        network: "base-sepolia",
      },
    },
    {
      url: facilitatorUrl,
    },
  ),
);

app.get("/weather", (req, res) => {
  res.send({
    report: {
      weather: "sunny",
      temperature: 70,
    },
  });
});

app.get("/premium/content", (req, res) => {
  res.send({
    content: "This is premium content",
  });
});

app.listen(4021, () => {
  console.log(`Server listening at http://localhost:${4021}`);
});


import { config } from "dotenv";
import express from "express";
import { exact } from "x402/schemes";
import {
  Network,
  PaymentPayload,
  PaymentRequirements,
  Price,
  Resource,
  settleResponseHeader,
} from "x402/types";
import { useFacilitator } from "x402/verify";
import { processPriceToAtomicAmount } from "x402/shared";

config();

const facilitatorUrl = process.env.FACILITATOR_URL as Resource;
const payTo = process.env.ADDRESS as `0x${string}`;

if (!facilitatorUrl || !payTo) {
  console.error("Missing required environment variables");
  process.exit(1);
}

const app = express();
const { verify, settle } = useFacilitator({ url: facilitatorUrl });
const x402Version = 1;

/**
 * Creates payment requirements for a given price and network
 *
 * @param price - The price to be paid for the resource
 * @param network - The blockchain network to use for payment
 * @param resource - The resource being accessed
 * @param description - Optional description of the payment
 * @returns An array of payment requirements
 */
function createExactPaymentRequirements(
  price: Price,
  network: Network,
  resource: Resource,
  description = "",
): PaymentRequirements {
  const atomicAmountForAsset = processPriceToAtomicAmount(price, network);
  if ("error" in atomicAmountForAsset) {
    throw new Error(atomicAmountForAsset.error);
  }
  const { maxAmountRequired, asset } = atomicAmountForAsset;

  return {
    scheme: "exact",
    network,
    maxAmountRequired,
    resource,
    description,
    mimeType: "",
    payTo: payTo,
    maxTimeoutSeconds: 60,
    asset: asset.address,
    outputSchema: undefined,
    extra: {
      name: asset.eip712.name,
      version: asset.eip712.version,
    },
  };
}

/**
 * Verifies a payment and handles the response
 *
 * @param req - The Express request object
 * @param res - The Express response object
 * @param paymentRequirements - The payment requirements to verify against
 * @returns A promise that resolves to true if payment is valid, false otherwise
 */
async function verifyPayment(
  req: express.Request,
  res: express.Response,
  paymentRequirements: PaymentRequirements[],
): Promise<boolean> {
  const payment = req.header("X-PAYMENT");
  if (!payment) {
    res.status(402).json({
      x402Version,
      error: "X-PAYMENT header is required",
      accepts: paymentRequirements,
    });
    return false;
  }

  let decodedPayment: PaymentPayload;
  try {
    decodedPayment = exact.evm.decodePayment(payment);
    decodedPayment.x402Version = x402Version;
  } catch (error) {
    res.status(402).json({
      x402Version,
      error: error || "Invalid or malformed payment header",
      accepts: paymentRequirements,
    });
    return false;
  }

  try {
    const response = await verify(decodedPayment, paymentRequirements[0]);
    if (!response.isValid) {
      res.status(402).json({
        x402Version,
        error: response.invalidReason,
        accepts: paymentRequirements,
        payer: response.payer,
      });
      return false;
    }
  } catch (error) {
    res.status(402).json({
      x402Version,
      error,
      accepts: paymentRequirements,
    });
    return false;
  }

  return true;
}

// Delayed settlement example endpoint
app.get("/delayed-settlement", async (req, res) => {
  const resource = `${req.protocol}://${req.headers.host}${req.originalUrl}` as Resource;
  const paymentRequirements = [
    createExactPaymentRequirements(
      "$0.001",
      // network: "base" // uncomment for Base mainnet
      "base-sepolia",
      resource,
      "Access to weather data (async)",
    ),
  ];

  const isValid = await verifyPayment(req, res, paymentRequirements);
  if (!isValid) return;

  // Return weather data immediately
  res.json({
    report: {
      weather: "sunny",
      temperature: 70,
    },
  });

  // Process payment asynchronously
  try {
    const settleResponse = await settle(
      exact.evm.decodePayment(req.header("X-PAYMENT")!),
      paymentRequirements[0],
    );
    const responseHeader = settleResponseHeader(settleResponse);
    // In a real application, you would store this response header
    // and associate it with the payment for later verification
    console.log("Payment settled:", responseHeader);
  } catch (error) {
    console.error("Payment settlement failed:", error);
    // In a real application, you would handle the failed payment
    // by marking it for retry or notifying the user
  }
});

// Dynamic price example endpoint
app.get("/dynamic-price", async (req, res) => {
  // Use query params, body, or external factors to determine if price is impacted
  const multiplier = parseInt((req.query.multiplier as string) ?? "1");
  // Adjust pricing based on impact from inputs
  const price = 0.001 * multiplier;

  const resource = `${req.protocol}://${req.headers.host}${req.originalUrl}` as Resource;
  const paymentRequirements = [
    createExactPaymentRequirements(
      price, // Expect dynamic pricing
      // network: "base" // uncomment for Base mainnet
      "base-sepolia",
      resource,
      "Access to weather data",
    ),
  ];

  const isValid = await verifyPayment(req, res, paymentRequirements);
  if (!isValid) return;

  try {
    // Process payment synchronously
    const settleResponse = await settle(
      exact.evm.decodePayment(req.header("X-PAYMENT")!),
      paymentRequirements[0],
    );
    const responseHeader = settleResponseHeader(settleResponse);
    res.setHeader("X-PAYMENT-RESPONSE", responseHeader);

    // Return the weather data
    res.json({
      report: {
        success: "sunny",
        temperature: 70,
      },
    });
  } catch (error) {
    res.status(402).json({
      x402Version,
      error,
      accepts: paymentRequirements,
    });
  }
});

// Multiple payment requirements example endpoint
app.get("/multiple-payment-requirements", async (req, res) => {
  const resource = `${req.protocol}://${req.headers.host}${req.originalUrl}` as Resource;

  // Payment requirements is an array. You can mix and match tokens, prices, and networks.
  const paymentRequirements = [
    createExactPaymentRequirements("$0.001", "base", resource),
    createExactPaymentRequirements(
      {
        amount: "1000",
        asset: {
          address: "0x036CbD53842c5426634e7929541eC2318f3dCF7e",
          decimals: 6,
          eip712: {
            name: "USDC",
            version: "2",
          },
        },
      },
      // network: "base" // uncomment for Base mainnet
      "base-sepolia",
      resource,
    ),
  ];

  const isValid = await verifyPayment(req, res, paymentRequirements);
  if (!isValid) return;

  try {
    // Process payment synchronously
    const settleResponse = await settle(
      exact.evm.decodePayment(req.header("X-PAYMENT")!),
      paymentRequirements[0],
    );
    const responseHeader = settleResponseHeader(settleResponse);
    res.setHeader("X-PAYMENT-RESPONSE", responseHeader);

    // Return the weather data
    res.json({
      report: {
        success: "sunny",
        temperature: 70,
      },
    });
  } catch (error) {
    res.status(402).json({
      x402Version,
      error,
      accepts: paymentRequirements,
    });
  }
});

app.listen(4021, () => {
  console.log(`Server listening at http://localhost:4021`);
});


Getting Started with AgentKit
AgentKit provides a simple way to create AI agents that can interact with blockchain networks. This guide will show you how to get started using our CLI tools.

AgentKit

Create Your First Agent
This section will guide you through the process of creating a new AgentKit project using the TypeScript CLI. Through this process, you will generate a NextJs fullstack application, or a Model Context Protocol server to use with Claude Desktop.

Prerequisites
Before you begin, make sure you have:

Node.js 18 or later installed – Download here
npm 9 or later installed (comes bundled with Node.js)
Check your Node.js and npm versions:

node --version  # Should be 18+
npm --version   # Should be 9+

Creating a New Project
The fastest way to get started is using our TypeScript CLI:

npm create onchain-agent@latest

This command will guide you through an interactive setup process:

Choose your AI Framework

LangChain: Popular framework for building AI applications
Vercel AI SDK: Build AI-powered streaming text and chat UIs
Model Context Protocol: Standardized protocol for AI model interactions
Project Template (based on your framework choice)

LangChain & Vercel AI SDK: Full-stack Next.js application with:
React for the frontend
Tailwind CSS for styling
ESLint for code quality
TypeScript configuration
Model Context Protocol: MCP server project for Claude Desktop integration
Blockchain Network

Select from preconfigured networks (Base, EVM, Solana, etc.)
Optionally specify custom chain IDs
Wallet Provider

CDP Smart Wallets: Account abstraction with advanced features
CDP Server Wallets: Secure server-side wallet management
Viem: Local private key management
Privy Server Wallets: Managed custody solution
Privy Delegated Embedded Wallets: Client-side wallets with delegation
Running Your Project
Follow the instructions displayed in your CLI to get running. Be sure to check:

The .env-local file in your project root for instructions on obtaining API keys
Your generated project's README for additional setup details and customization options
Component Generation
The CLI also installs the agentkit command globally, allowing you to generate additional components.

These generators will create TypeScript files in your current working directory.

# Available generators
agentkit generate wallet-provider    # Generate a custom wallet provider
agentkit generate action-provider    # Generate a custom action provider
agentkit generate prepare            # Generate framework-agnostic AgentKit setup
agentkit generate create-agent       # Generate framework-specific agent creation

Note: If the above commands print the error agentkit: not found, ensure the agentkit cli is installed by running the following command:

npm install -g create-onchain-agent/@latest


Agent Actions
Actions are grouped into action providers, which may have specific dependencies like API keys. You can find all of the action providers and actions supported by AgentKit at the following links:

Python version
Node.js version
Generally, Node.js supports more crypto-specific actions than the Python version.

By default, AgentKit supports the following actions in the 'wallet' action provider:

get_wallet_details - Get details about the Wallet, like the address
native_transfer - Transfer native asset between addresses
get_balance - Get the balance of the native asset
Adding Action Provider Groupings
Adding an existing action provider to your agent is a two-step process:

Import the action provider to your file
Add the action provider to your AgentKit instance
import {
  AgentKit,
  CdpWalletProvider,
  walletActionProvider,
  erc721ActionProvider,
  cdpApiActionProvider,
  cdpWalletActionProvider,
  pythActionProvider,
} from "@coinbase/agentkit";

const erc721 = erc721ActionProvider();
const pyth = pythActionProvider();
const wallet = walletActionProvider(); // default action package: get balance, native transfer, and get wallet details
const cdp = cdpApiActionProvider({ // for providers that require API keys include them in their instantiation
  apiKeyName: process.env.CDP_API_KEY_NAME,
  apiKeyPrivateKey: process.env.CDP_API_KEY_PRIVATE_KEY?.replace(/\\n/g, "\n"),
});

const agentKit = await AgentKit.from({
  walletProvider,
  actionProviders: [erc721, pyth, wallet, cdp],
});

Creating an Action Provider
Action providers define the actions that an agent can take. They are created by subclassing the ActionProvider abstract class.

import { ActionProvider, WalletProvider, Network } from "@coinbase/agentkit";

// Define an action provider that uses a wallet provider.
class MyActionProvider extends ActionProvider<WalletProvider> {
    constructor() {
        super("my-action-provider", []);
    }

    // Define if the action provider supports the given network
    supportsNetwork = (network: Network) => true;
}

Adding Actions to an Action Provider
Actions are defined as instance methods on the action provider class with the @CreateAction decorator. Actions can use a wallet provider or not and always return a Promise that resolves to a string.

Required Typescript Compiler Options

Creating actions with the @CreateAction decorator requires the following compilerOptions to be included in your project's tsconfig.json.

{
    "compilerOptions": {
        "experimentalDecorators": true,
        "emitDecoratorMetadata": true
    }
} 

Steps to create an action

Define the action schema. Action schemas are defined using the zod library.
import { z } from "zod";

export const MyActionSchema = z.object({
  myField: z.string(),
});

Define the action implementation.
import { ActionProvider, WalletProvider, Network, CreateAction } from "@coinbase/agentkit";

class MyActionProvider extends ActionProvider<WalletProvider> {
    constructor() {
        super("my-action-provider", []);
    }

    @CreateAction({
        name: "my-action",
        description: "My action description",
        schema: MyActionSchema,
    })
    async myAction(args: z.infer<typeof MyActionSchema>): Promise<string> {
        return args.myField;
    }

    supportsNetwork = (network: Network) => true;
}

export const myActionProvider = () => new MyActionProvider();

Adding Actions to your Action Provider that use a Wallet Provider

Actions that use a wallet provider can be defined as instance methods on the action provider class with the @CreateAction decorator that have a WalletProvider as the first parameter.

class MyActionProvider extends ActionProvider<WalletProvider> {
    constructor() {
        super("my-action-provider", []);
    }

    @CreateAction({
        name: "my-action",
        description: "My action description",
        schema: MyActionSchema,
    })
    async myAction(walletProvider: WalletProvider, args: z.infer<typeof MyActionSchema>): Promise<string> {
        return walletProvider.signMessage(args.myField);
    }

    supportsNetwork = (network: Network) => true;
}

Adding an Action Provider to your AgentKit instance

const agentKit = new AgentKit({
  cdpApiKeyName: "CDP API KEY NAME",
  cdpApiKeyPrivate: "CDP API KEY PRIVATE KEY",
  actionProviders: [myActionProvider()],
});

For actions to be made available for any agent, we welcome open-source contributions to AgentKit for adding more actions! Please see our contribution guide for more information.


# Across Action Provider

This directory contains the **AcrossActionProvider** implementation, which provides actions to interact with the **Across Protocol** for bridging tokens across multiple EVM chains.

## Directory Structure

```
across/
├── acrossActionProvider.ts        # Main provider with Across Protocol functionality
├── acrossActionProvider.test.ts   # Tests
├── schemas.ts                     # Bridge token schema
├── utils.ts                       # Utility functions for Across integration
├── index.ts                       # Main exports
└── README.md                      # This file
```

## Actions

- `bridge_token`: Bridge tokens from one chain to another using the Across Protocol
- `check_deposit_status`: Check the status of a cross-chain bridge deposit on the Across Protocol 

## Adding New Actions

To add new Across actions:

1. Define your action schema in `schemas.ts`
2. Implement the action in `acrossActionProvider.ts`
3. Add tests in `acrossActionProvider.test.ts`

## Network Support

The Across provider supports cross-chain transfers between EVM-compatible chains, for example:
- Ethereum Mainnet to Base Mainnet
- Base Sepolia to Ethereum Sepolia
The status of bridge deposit can only be checked on Mainnets.

## ⚠️ Warning

Before briding funds, always make sure that you have access to the destination address on the destination chain!

Note that when using a CDP server wallet with CdpWalletProvider, a new wallet address is generated for each chain. This means that if you bridge tokens to the sender's address on one chain, you may not be able to access those funds on the destination chain within AgentKit since a different wallet address will be used. 
While you can export the private key to access funds in external wallets, it's recommended to either use ViemWalletProvider for consistent addresses across chains or ensure the destination address is different from the sender's address.

## Configuration

The provider requires the following configuration:
- `privateKey`: Private key of the wallet provider

## Notes

For more information on the **Across Protocol**, visit [Across Protocol Documentation](https://docs.across.to/). 


import { acrossActionProvider } from "./acrossActionProvider";
import { EvmWalletProvider } from "../../wallet-providers";
import { Network } from "../../network";
import { createPublicClient, PublicClient } from "viem";

// Mock the necessary imports and modules
jest.mock("viem", () => {
  return {
    ...jest.requireActual("viem"),
    createPublicClient: jest.fn(),
    createWalletClient: jest.fn(() => ({
      writeContract: jest.fn().mockResolvedValue("0xdepositTxHash"),
    })),
    http: jest.fn(),
    formatUnits: jest.fn().mockImplementation((value, decimals) => {
      // Simple mock implementation just for testing
      if (typeof value === "bigint") {
        if (decimals === 18) {
          return (Number(value) / 10 ** 18).toString();
        }
        return value.toString();
      }
      return value.toString();
    }),
    parseUnits: jest.fn().mockImplementation((value, decimals) => {
      if (decimals === 18) {
        return BigInt(Number(value) * 10 ** 18);
      }
      return BigInt(value);
    }),
  };
});

jest.mock("viem/accounts", () => ({
  privateKeyToAccount: jest.fn().mockReturnValue({
    address: "0x9876543210987654321098765432109876543210",
  }),
}));

// Mock the network module
jest.mock("../../network", () => {
  return {
    ...jest.requireActual("../../network"),
    NETWORK_ID_TO_VIEM_CHAIN: {
      "ethereum-mainnet": {
        id: 1,
        name: "Ethereum",
        network: "mainnet",
      },
      optimism: {
        id: 10,
        name: "Optimism",
        network: "optimism",
      },
      "base-sepolia": {
        id: 84532,
        name: "Base Sepolia",
        network: "base-sepolia",
      },
    },
    CHAIN_ID_TO_NETWORK_ID: {
      "1": "ethereum-mainnet",
      "10": "optimism",
      "84532": "base-sepolia",
    },
  };
});
